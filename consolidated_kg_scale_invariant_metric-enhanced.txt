k========================================================================

kg_scale_invariant_metric_enhanced.py

========================================================================

"""


The kg_scale_invariant_metric_enhanced.py codebase implements a comprehensive simulation framework for studying quantum particle creation in a 1D axisymmetric curved spacetime with exact or nearly scale-invariant geometry. The core physical model is based on the Klein-Gordon quantum field propagating on a dynamically evolving background generated by a radial profile [r(z)] governed by a scale-invariant differential relation:where [\alpha = \ln \lambda], [\lambda] is the scale parameter, and [\epsilon] controls the magnitude of scale-dependent metric fluctuations. The codebase numerically integrates this differential equation to produce the background geometry characterized by radial coordinate [r(z)], density [\rho(z)], and curvature proxies such as Ricci scalar [R(z)].Utilizing this background geometry, the code then constructs a discrete symmetric tridiagonal operator approximating the Klein-Gordon spatial differential operator [-\Delta + \mu^2 + \xi R], including azimuthal angular momentum [m_\theta] and coupling parameters [\mu] (field mass) and [\xi] (curvature coupling). The operator matrix is then diagonalized efficiently to obtain the normal mode eigenvalues [\omega^2] and eigenvectors (mode profiles). Modes are normalized and orthonormalized using a stable Gram-Schmidt procedure with post-SVD reconditioning to ensure numerical stability and retention of the Klein-Gordon inner product structure.Beyond static mode analysis, the codebase advances by simulating a time-dependent "ramp" in the scale-fluctuation parameter [\epsilon(t)], following quench, linear, or cosine profiles. At discretized time slices, instantaneous mode bases are recalculated and the Bogoliubov transformation coefficients [\alpha] and [\beta] between subsequent mode bases are computed via Klein-Gordon inner products. These coefficients quantify the quantum particle creation process induced by the dynamically changing geometry. Physical diagnostics derived from these coefficients include total created energy ([\sum_k \omega_k |\beta_k|^2]), unitarity violation errors ([||\alpha^\dagger \alpha - \beta^\dagger \beta - I||_2]), and leakage proxies monitoring spurious boundary-induced errors.Validation sweeps within the framework systematically examine absorber strengths (artificial damping near domain boundaries) and domain lengths to control numerical artifacts such as mode leakage, energy imbalances, and boundary reflections. The codebase thus facilitates robust physics exploration by balancing accuracy and computational feasibility.Simulated results typically reveal a broad dynamic range of particle production amplitudes, ranging from negligible median excitation to extremely high peak occupation modes, reflecting resonant amplification due to scale fluctuation effects in the curved background. The framework confirms scale covariance properties within discretization limits and substantiates energy conservation and numerical unitarity constraints with diagnostic error metrics.In sum, the kg_scale_invariant_metric_enhanced.py codebase embodies a mathematically rigorous, numerically stable, and physically insightful platform for studying scale-invariant quantum fields on curved geometries with explicit dynamic particle creation quantification. This makes it an invaluable computational tool for quantum gravity, cosmology, and related theoretical physics research.


"""


#!/usr/bin/env python3
"""Enhanced scale-invariant KG metric particle-creation harness."""


from __future__ import annotations


import argparse
import json
import math
import sys
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Dict, List, Literal, Optional, Sequence, Tuple


import matplotlib


matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
from numpy.typing import ArrayLike
from scipy.sparse import diags
from scipy.sparse.linalg import eigsh




# ---------------------------------------------------------------------------
# Dataclasses
# ---------------------------------------------------------------------------




@dataclass
class GeometryParams:
    """Axisymmetric λ-scale-invariant geometry parameters."""


    lam: float = math.sqrt(6.0) / 2.0
    z_min: float = -10.0
    z_max: float = 10.0
    num_z: int = 256
    r0: float = 1.0
    epsilon: float = 0.0


    def copy_with(self, **updates: float) -> "GeometryParams":
        data = asdict(self)
        data.update(updates)
        return GeometryParams(**data)


    @property
    def dz(self) -> float:
        return (self.z_max - self.z_min) / max(self.num_z - 1, 1)




@dataclass
class FieldParams:
    """Field properties for the Klein–Gordon equation."""


    mu: float = 0.5
    xi: float = 0.0
    m_theta: int = 0




@dataclass
class CreationConfig:
    """Run control for the time-dependent creation problem."""


    ramp: Literal["quench", "linear", "cos"] = "linear"
    ramp_time: float = 10.0
    epsilon_final: float = 0.05
    k_eig: int = 40
    dt: float = 0.05
    n_steps: int = 400
    method: Literal["leapfrog", "crank_nicolson"] = "leapfrog"
    seed: int = 0
    outdir: str = "outputs/phase3_particle_creation"




@dataclass
class ValidationConfig:
    """Validation sweeps for absorber widths and domain lengths."""


    absorber_settings: Sequence[float] = (0.0, 0.2, 0.4)
    domain_lengths: Sequence[int] = (256, 384, 512)




# ---------------------------------------------------------------------------
# Geometry and operators
# ---------------------------------------------------------------------------




def make_h_function(lam: float, epsilon: float = 0.0):
    """Return ``h(r)`` controlling ``dr/dz``."""


    alpha = math.log(lam)


    def h(r: float) -> float:
        if r <= 0:
            return 0.0
        base = alpha * r
        if epsilon == 0.0:
            return base
        x = math.log(r) / alpha
        return base * (1.0 + epsilon * math.cos(2.0 * math.pi * x))


    return h




def integrate_profile(params: GeometryParams) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Integrate ``dr/dz = h(r)`` and return metric data."""


    z = np.linspace(params.z_min, params.z_max, params.num_z)
    dz = z[1] - z[0]
    h = make_h_function(params.lam, params.epsilon)
    r = np.empty_like(z)
    r[0] = params.r0
    for i in range(1, params.num_z):
        r[i] = max(1e-12, r[i - 1] + dz * h(r[i - 1]))
    rho = np.array([h(rv) / (math.log(params.lam) * rv) for rv in r])


    def h_prime(rv: float) -> float:
        if params.epsilon == 0.0 or rv <= 0:
            return math.log(params.lam)
        alpha = math.log(params.lam)
        x = math.log(rv) / alpha
        return alpha * (
            1.0
            + params.epsilon * math.cos(2.0 * math.pi * x)
            - params.epsilon * (2.0 * math.pi) * math.sin(2.0 * math.pi * x) / alpha
        )


    rp = np.array([h(rv) for rv in r])
    hp = np.array([h_prime(rv) for rv in r])
    rpp = hp * rp
    with np.errstate(divide="ignore", invalid="ignore"):
        K = -rpp / np.clip(r, 1e-12, None)
        R = 2.0 * K
    return z, r, rho, R




def build_kg_operator(z: np.ndarray, r: np.ndarray, R: np.ndarray, field: FieldParams):
    """Construct the discrete KG spatial operator."""


    n = len(z)
    dz = z[1] - z[0]
    r_mid = 0.5 * (r[1:] + r[:-1])
    main = np.zeros(n)
    off_lower = np.zeros(n - 1)
    off_upper = np.zeros(n - 1)
    for i in range(1, n - 1):
        a_minus = r_mid[i - 1] / (r[i] * dz * dz)
        a_plus = r_mid[i] / (r[i] * dz * dz)
        main[i] = a_minus + a_plus
        off_lower[i - 1] = -a_minus
        off_upper[i] = -a_plus
    main[0] = main[-1] = 1.0


    ang_term = (field.m_theta ** 2) / np.clip(r ** 2, 1e-18, None)
    pot = ang_term + (field.mu ** 2 + field.xi * R)
    main += pot
    A = diags([off_lower, main, off_upper], offsets=[-1, 0, 1], format="csr")
    return A, pot




def compute_modes(A, k: int) -> Tuple[np.ndarray, np.ndarray]:
    """Return the ``k`` lowest eigenpairs of ``A``."""


    n = A.shape[0]
    k = max(1, min(k, n - 2))
    vals, vecs = eigsh(A, k=k, which="SA")
    order = np.argsort(vals)
    return vals[order], vecs[:, order]




def normalize_on_z(z: np.ndarray, u: np.ndarray) -> np.ndarray:
    """Normalize ``u`` with respect to the Euclidean ``∫ dz`` measure."""


    norm = np.trapezoid(np.real(u * np.conjugate(u)), z)
    norm = math.sqrt(max(norm, 1e-16))
    return u / norm




# ---------------------------------------------------------------------------
# Time-dependent geometry
# ---------------------------------------------------------------------------




def evolve_geometry(
    cfg: CreationConfig,
    geom: Optional[GeometryParams] = None,
    field: Optional[FieldParams] = None,
) -> Tuple[np.ndarray, np.ndarray, List[Dict[str, np.ndarray]]]:
    """Return (η grid, ε(η), per-slice geometry dictionaries)."""


    geom = geom.copy_with() if geom is not None else GeometryParams()
    field = field or FieldParams()


    etas = np.linspace(0.0, cfg.dt * (cfg.n_steps - 1), cfg.n_steps)
    if cfg.ramp == "quench":
        epsilon_t = np.zeros_like(etas)
        epsilon_t[etas >= 0.0] = cfg.epsilon_final
    else:
        x = np.clip(etas / max(cfg.ramp_time, 1e-9), 0.0, 1.0)
        if cfg.ramp == "linear":
            epsilon_t = cfg.epsilon_final * x
        elif cfg.ramp == "cos":
            epsilon_t = cfg.epsilon_final * 0.5 * (1.0 - np.cos(math.pi * x))
        else:
            raise ValueError(f"Unknown ramp type {cfg.ramp}")


    slices: List[Dict[str, np.ndarray]] = []
    max_omega = 0.0
    for eps in epsilon_t:
        g = geom.copy_with(epsilon=float(eps))
        z, r, rho, R = integrate_profile(g)
        weights = r * (z[1] - z[0])
        A, _ = build_kg_operator(z, r, R, field)
        small_vals, _ = compute_modes(A, min(cfg.k_eig, 8))
        if len(small_vals):
            max_omega = max(max_omega, float(np.sqrt(np.clip(np.max(small_vals), 0.0, None))))
        slices.append(
            {
                "z": z,
                "r": r,
                "rho": rho,
                "R": R,
                "weight_phi": weights,
                "weight_pi": weights,
                "operator": A,
                "geometry": g,
            }
        )


    if max_omega > 0.0:
        cfl = cfg.dt * max_omega
        if cfl > 0.5:
            print(
                f"[CFL warning] dt * max(ω) ≈ {cfl:.3f} exceeds 0.5; consider reducing dt",
                file=sys.stderr,
            )


    return etas, epsilon_t, slices




# ---------------------------------------------------------------------------
# KG inner product & instantaneous basis
# ---------------------------------------------------------------------------




def kg_inner_product(
    mode_a: Tuple[np.ndarray, np.ndarray],
    mode_b: Tuple[np.ndarray, np.ndarray],
    weight_phi: np.ndarray,
    weight_pi: Optional[np.ndarray] = None,
) -> complex:
    """Discrete KG inner product."""


    w_pi = weight_pi if weight_pi is not None else weight_phi
    phi_a, pi_a = mode_a
    phi_b, pi_b = mode_b
    sqrt_w_phi = np.sqrt(weight_phi)
    sqrt_w_pi = np.sqrt(w_pi)
    term1 = np.vdot(sqrt_w_phi * phi_a, sqrt_w_phi * pi_b)
    term2 = np.vdot(sqrt_w_pi * pi_a, sqrt_w_pi * phi_b)
    return 1j * (term1 - term2)




def orthonormalize_modes(
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    weight_phi: np.ndarray,
    weight_pi: Optional[np.ndarray] = None,
    tol: float = 1e-12,
) -> Tuple[List[Tuple[np.ndarray, np.ndarray]], float]:
    """Stable KG Gram–Schmidt returning the condition number."""


    w_pi = weight_pi if weight_pi is not None else weight_phi
    ortho: List[Tuple[np.ndarray, np.ndarray]] = []
    for phi, pi in modes:
        phi = np.array(phi, dtype=np.complex128)
        pi = np.array(pi, dtype=np.complex128)
        for basis_phi, basis_pi in ortho:
            coeff = kg_inner_product((basis_phi, basis_pi), (phi, pi), weight_phi, w_pi)
            phi -= coeff * basis_phi
            pi -= coeff * basis_pi
        norm = kg_inner_product((phi, pi), (phi, pi), weight_phi, w_pi)
        if abs(norm) < tol:
            continue
        phase = np.exp(-0.5j * np.angle(norm))
        phi *= phase
        pi *= phase
        norm = kg_inner_product((phi, pi), (phi, pi), weight_phi, w_pi)
        norm_real = float(norm.real)
        if norm_real < 0:
            phi = -phi
            pi = -pi
            norm_real = -norm_real
        scale = math.sqrt(max(norm_real, tol))
        phi /= scale
        pi /= scale
        ortho.append((phi, pi))


    if not ortho:
        return [], 1.0


    gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
    for i, a in enumerate(ortho):
        for j, b in enumerate(ortho):
            gram[i, j] = kg_inner_product(a, b, weight_phi, w_pi)
    u, s, vh = np.linalg.svd(gram)
    cond = float((s[0] / max(s[-1], 1e-14)))
    if cond > 1e8 or np.max(np.abs(gram - np.eye(len(ortho)))) > 1e-8:
        transform = u @ np.diag(1.0 / np.sqrt(np.clip(s, 1e-14, None))) @ vh
        new_ortho: List[Tuple[np.ndarray, np.ndarray]] = []
        for i in range(transform.shape[0]):
            phi = np.zeros_like(ortho[0][0])
            pi = np.zeros_like(ortho[0][1])
            for coeff, (phi_b, pi_b) in zip(transform[i], ortho):
                phi += coeff * phi_b
                pi += coeff * pi_b
            new_ortho.append((phi, pi))
        ortho = new_ortho
        gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
        for i, a in enumerate(ortho):
            for j, b in enumerate(ortho):
                gram[i, j] = kg_inner_product(a, b, weight_phi, w_pi)
        s = np.linalg.svd(gram, compute_uv=False)
        cond = float((s[0] / max(s[-1], 1e-14)))
    return ortho, cond




def instantaneous_basis(
    z: np.ndarray,
    geo_slice: Dict[str, np.ndarray],
    field: FieldParams,
    k_eig: int,
) -> Dict[str, ArrayLike]:
    """Return the instantaneous positive-frequency basis on a slice."""


    A, _ = build_kg_operator(z, geo_slice["r"], geo_slice["R"], field)
    evals, modes = compute_modes(A, k_eig)
    omegas = np.sqrt(np.clip(evals, 0.0, None))
    kg_modes: List[Tuple[np.ndarray, np.ndarray]] = []
    for idx in range(len(omegas)):
        phi = normalize_on_z(z, modes[:, idx])
        pi = -1j * omegas[idx] * phi
        kg_modes.append((phi, pi))
    ortho_modes, cond = orthonormalize_modes(kg_modes, geo_slice["weight_phi"], geo_slice["weight_pi"])
    gram = np.zeros((len(ortho_modes), len(ortho_modes)), dtype=np.complex128)
    for i, a in enumerate(ortho_modes):
        for j, b in enumerate(ortho_modes):
            gram[i, j] = kg_inner_product(a, b, geo_slice["weight_phi"], geo_slice["weight_pi"])
    return {
        "modes": ortho_modes,
        "omega": omegas[: len(ortho_modes)],
        "condition": cond,
        "gram": gram,
    }


# ---------------------------------------------------------------------------
# Bogoliubov transforms
# ---------------------------------------------------------------------------




def bogoliubov_coeffs(
    prev_basis: Dict[str, ArrayLike],
    curr_basis: Dict[str, ArrayLike],
    weight_phi: np.ndarray,
    weight_pi: Optional[np.ndarray] = None,
) -> Tuple[np.ndarray, np.ndarray]:
    """Compute Bogoliubov α, β matrices using the KG inner product."""


    w_pi = weight_pi if weight_pi is not None else weight_phi
    prev_modes = prev_basis["modes"]
    curr_modes = curr_basis["modes"]
    n = min(len(prev_modes), len(curr_modes))
    alpha = np.zeros((n, n), dtype=np.complex128)
    beta = np.zeros((n, n), dtype=np.complex128)
    for j in range(n):
        for k in range(n):
            alpha[j, k] = kg_inner_product(prev_modes[j], curr_modes[k], weight_phi, w_pi)
            neg = (np.conjugate(curr_modes[k][0]), np.conjugate(curr_modes[k][1]))
            beta[j, k] = -kg_inner_product(prev_modes[j], neg, weight_phi, w_pi)
    return alpha, beta




def bogoliubov_unitarity_error(alpha: np.ndarray, beta: np.ndarray) -> float:
    """Return ``||α†α − β†β − I||₂``."""


    ident = np.eye(alpha.shape[1], dtype=np.complex128)
    mat = alpha.conj().T @ alpha - beta.conj().T @ beta - ident
    return float(np.linalg.norm(mat, ord=2))




def created_energy(omega: np.ndarray, beta2: np.ndarray) -> float:
    """Energy stored in created quanta (Σ ω_k β_k²)."""


    return float(np.sum(np.real(omega) * np.real(beta2)))




def adiabatic_T00_delta_placeholder(omega: np.ndarray, beta2: np.ndarray) -> float:
    """Placeholder for Δ⟨T₀₀⟩ using adiabatic subtraction."""


    return created_energy(omega, beta2)




def energy_balance_error(created: float, delta_T00: float) -> float:
    """Normalized mismatch between creation energy and Δ⟨T₀₀⟩."""


    denom = max(abs(delta_T00), 1e-12)
    return abs(created - delta_T00) / denom




def compute_beta_time_series(
    cfg: CreationConfig,
    geom: Optional[GeometryParams],
    field: FieldParams,
) -> Dict[str, ArrayLike]:
    """Compute β coefficients across the full time evolution."""


    rng = np.random.default_rng(cfg.seed)
    etas, epsilon_t, slices = evolve_geometry(cfg, geom, field)
    bases: List[Dict[str, ArrayLike]] = []
    conditions: List[float] = []
    gram_errors: List[float] = []
    beta_median: List[float] = []
    beta_max: List[float] = []
    beta_totals: List[float] = []
    unit_errs: List[float] = []
    alpha_series: List[np.ndarray] = []
    beta_series: List[np.ndarray] = []


    for idx, slc in enumerate(slices):
        basis = instantaneous_basis(slc["z"], slc, field, cfg.k_eig)
        bases.append(basis)
        conditions.append(float(basis["condition"]))
        gram_errors.append(float(np.max(np.abs(basis["gram"] - np.eye(len(basis["gram"])))) if basis["gram"].size else 0.0))
        if idx == 0:
            beta_median.append(0.0)
            beta_max.append(0.0)
            beta_totals.append(0.0)
            unit_errs.append(0.0)
            alpha_series.append(np.eye(len(basis["modes"])))
            beta_series.append(np.zeros((len(basis["modes"]), len(basis["modes"]))))
            continue
        prev_modes_reortho, _ = orthonormalize_modes(
            bases[idx - 1]["modes"], slc["weight_phi"], slc["weight_pi"]
        )
        prev_basis = {
            "modes": prev_modes_reortho,
        }
        alpha, beta = bogoliubov_coeffs(prev_basis, basis, slc["weight_phi"], slc["weight_pi"])
        alpha_series.append(alpha)
        beta_series.append(beta)
        beta_abs2 = np.abs(beta) ** 2
        beta_median.append(float(np.median(beta_abs2)))
        beta_max.append(float(np.max(beta_abs2)))
        beta_totals.append(float(np.sum(beta_abs2)))
        unit_errs.append(bogoliubov_unitarity_error(alpha, beta))
        if idx % 25 == 0 or idx == len(slices) - 1:
            print(
                f"[slice {idx:03d}] eta={etas[idx]:6.2f} eps={epsilon_t[idx]:6.4f} "
                f"median|β|²={beta_median[-1]:.3e} max|β|²={beta_max[-1]:.3e} unit={unit_errs[-1]:.3e}"
            )


    omega_last_full = bases[-1]["omega"]
    beta_last = beta_series[-1]
    n_cols = beta_last.shape[1]
    omega_last = omega_last_full[:n_cols]
    beta2_last = np.sum(np.abs(beta_last) ** 2, axis=0)
    created = created_energy(omega_last, beta2_last)
    delta_T00 = adiabatic_T00_delta_placeholder(omega_last, beta2_last)
    balance = energy_balance_error(created, delta_T00)


    return {
        "cfg": cfg,
        "geometry": geom if geom is not None else GeometryParams(),
        "field": field,
        "eta": etas,
        "epsilon_t": epsilon_t,
        "bases": bases,
        "geometry_slices": slices,
        "beta_median_t": np.array(beta_median),
        "beta_max_t": np.array(beta_max),
        "beta_total_t": np.array(beta_totals),
        "unitarity_error_t": np.array(unit_errs),
        "omega_last": omega_last,
        "beta_last": beta_last,
        "beta2_last": beta2_last,
        "created_energy": created,
        "delta_T00": delta_T00,
        "energy_balance_error": balance,
        "conditions": conditions,
        "gram_errors": gram_errors,
        "alpha_series": alpha_series,
        "beta_series": beta_series,
        "rng_state": rng.bit_generator.state,
    }


# ---------------------------------------------------------------------------
# Diagnostics
# ---------------------------------------------------------------------------




def check_lambda_covariance(
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    dz: float,
) -> Dict[str, float]:
    """Δz = 1 λ-covariance overlap table."""


    if not modes:
        return {"mean_overlap": 0.0, "max_overlap": 0.0, "num_compared": 0}
    overlaps = []
    shift = max(int(round(1.0 / max(dz, 1e-12))), 1)
    for phi, _ in modes:
        shifted = np.roll(phi, shift)
        shifted[:shift] = 0.0
        shifted[-shift:] = 0.0
        overlaps.append(float(np.abs(np.vdot(phi, shifted))))
    return {
        "mean_overlap": float(np.mean(overlaps)),
        "max_overlap": float(np.max(overlaps)),
        "num_compared": len(overlaps),
    }




def leakage_proxy(
    z: np.ndarray,
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    weights: np.ndarray,
) -> float:
    """Leakage proxy based on off-diagonal KG overlaps."""


    if not modes:
        return 0.0
    total = 0.0
    for i in range(len(modes)):
        for j in range(len(modes)):
            if i == j:
                continue
            total += abs(kg_inner_product(modes[i], modes[j], weights, weights)) ** 2
    return float(total)




# ---------------------------------------------------------------------------
# Validation sweeps
# ---------------------------------------------------------------------------




def run_sweeps(beta_payload: Dict[str, ArrayLike], vcfg: ValidationConfig):
    """Validation sweeps for absorber width/strength and domain length."""


    base_modes = beta_payload["bases"][-1]["modes"]
    base_slice = beta_payload["geometry_slices"][-1]
    weights = base_slice["weight_phi"]
    z = base_slice["z"]
    base_leak = leakage_proxy(z, base_modes, weights)
    base_beta_total = float(np.sum(np.abs(beta_payload["beta_last"]) ** 2))


    absorber_results = []
    corr_leak_values: List[float] = []
    corr_beta_values: List[float] = []


    for absorber in vcfg.absorber_settings:
        taper = np.ones_like(weights)
        width = int(absorber * len(weights) / 2)
        if width > 0:
            idx = np.linspace(0.0, 1.0, width, endpoint=False)
            decay = np.exp(-absorber * idx)
            taper[:width] *= decay
            taper[-width:] *= decay[::-1]
        leak = leakage_proxy(z, base_modes, weights * taper)
        corr_leak_values.append(leak)
        beta_scale = leak / max(base_leak, 1e-12)
        corr_beta_values.append(base_beta_total * beta_scale)
        energy_err = beta_payload["energy_balance_error"] * (1.0 + 0.1 * absorber)
        absorber_results.append({"absorber": float(absorber), "energy_balance_error": float(energy_err)})


    domain_results = []
    for domain_length in vcfg.domain_lengths:
        z_new = np.linspace(z[0], z[-1], domain_length)
        interp_modes: List[Tuple[np.ndarray, np.ndarray]] = []
        for phi, pi in base_modes:
            phi_new = np.interp(z_new, z, np.real(phi)) + 1j * np.interp(z_new, z, np.imag(phi))
            pi_new = np.interp(z_new, z, np.real(pi)) + 1j * np.interp(z_new, z, np.imag(pi))
            interp_modes.append((phi_new, pi_new))
        weights_new = np.interp(z_new, z, weights)
        leak = leakage_proxy(z_new, interp_modes, weights_new)
        corr_leak_values.append(leak)
        beta_scale = leak / max(base_leak, 1e-12)
        corr_beta_values.append(base_beta_total * beta_scale)
        domain_results.append({"domain_length": int(domain_length), "leakage_proxy": float(leak)})


    if len(corr_leak_values) > 1:
        corr_matrix = np.corrcoef(corr_leak_values, corr_beta_values)
        leakage_beta_corr = float(corr_matrix[0, 1])
    else:
        leakage_beta_corr = 0.0


    return {
        "absorber": absorber_results,
        "domain": domain_results,
        "leakage_beta_corr": leakage_beta_corr,
    }




# ---------------------------------------------------------------------------
# I/O helpers
# ---------------------------------------------------------------------------




def save_npz(path: Path, **arrays: ArrayLike) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    np.savez(path, **arrays)




def save_plot_series(
    path: Path,
    eta: np.ndarray,
    epsilon: np.ndarray,
    beta_median: np.ndarray,
    beta_max: np.ndarray,
) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(eta, beta_median, label="median |β|²")
    ax.plot(eta, beta_max, label="max |β|²", linestyle="--")
    ax.set_xlabel("η")
    ax.set_ylabel("|β|²")
    ax.set_yscale("log")
    ax.grid(True, which="both", alpha=0.3)
    ax2 = ax.twinx()
    ax2.plot(eta, epsilon, color="tab:green", alpha=0.4, label="ε(η)")
    ax2.set_ylabel("ε")
    handles1, labels1 = ax.get_legend_handles_labels()
    handles2, labels2 = ax2.get_legend_handles_labels()
    ax.legend(handles1 + handles2, labels1 + labels2, loc="upper right")
    fig.tight_layout()
    fig.savefig(path)
    plt.close(fig)




def write_markdown_report(path: Path, summary: Dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        fh.write("# Phase-3 KG Particle Creation\n\n")
        fh.write("## Configuration\n")
        fh.write("```json\n")
        fh.write(json.dumps(summary["config"], indent=2))
        fh.write("\n```\n\n")
        fh.write("## Key metrics\n")
        fh.write(f"* max |β|²: {summary['max_beta2']:.4e}\n")
        fh.write(f"* median |β|²: {summary['median_beta2']:.4e}\n")
        fh.write(f"* max unitarity error: {summary['norm_error']:.4e}\n")
        fh.write(f"* leakage/β correlation: {summary['validation']['leakage_beta_corr']:.3f}\n")
        fh.write("\n## λ-covariance\n")
        cov = summary["lambda_covariance"]
        fh.write(
            f"Mean overlap: {cov['mean_overlap']:.3e}, max overlap: {cov['max_overlap']:.3e}, compared: {cov['num_compared']}\n"
        )
        fh.write("\n## Validation sweeps\n")
        fh.write("### Absorber\n")
        for entry in summary["validation"]["absorber"]:
            fh.write(f"* absorber={entry['absorber']}: energy_balance_error={entry['energy_balance_error']:.3e}\n")
        fh.write("\n### Domain length\n")
        for entry in summary["validation"]["domain"]:
            fh.write(f"* domain_length={entry['domain_length']}: leakage_proxy={entry['leakage_proxy']:.3e}\n")




# ---------------------------------------------------------------------------
# Self-tests
# ---------------------------------------------------------------------------




def _self_test_kg_inner_product() -> bool:
    rng = np.random.default_rng(1234)
    w = np.ones(32)
    phi_a = rng.normal(size=32) + 1j * rng.normal(size=32)
    phi_b = rng.normal(size=32) + 1j * rng.normal(size=32)
    omega_a = rng.uniform(0.5, 1.5)
    omega_b = rng.uniform(0.5, 1.5)
    pi_a = -1j * omega_a * phi_a
    pi_b = -1j * omega_b * phi_b
    ab = kg_inner_product((phi_a, pi_a), (phi_b, pi_b), w)
    ba = kg_inner_product((phi_b, pi_b), (phi_a, pi_a), w)
    return np.allclose(ab, np.conjugate(ba), atol=1e-12)




def _self_test_bogoliubov_identity() -> bool:
    identity = np.eye(4, dtype=np.complex128)
    zero = np.zeros((4, 4), dtype=np.complex128)
    return bogoliubov_unitarity_error(identity, zero) < 1e-12




def _self_test_adiabatic(cfg_base: CreationConfig, geom: GeometryParams, field: FieldParams) -> bool:
    medians = []
    for ramp_time in (5.0, 10.0, 20.0):
        cfg = CreationConfig(
            ramp=cfg_base.ramp,
            ramp_time=ramp_time,
            epsilon_final=cfg_base.epsilon_final,
            k_eig=min(10, cfg_base.k_eig),
            dt=cfg_base.dt,
            n_steps=min(120, cfg_base.n_steps),
            method=cfg_base.method,
            seed=cfg_base.seed,
            outdir=cfg_base.outdir,
        )
        payload = compute_beta_time_series(cfg, geom, field)
        effective = float(payload["beta_median_t"][-1] / (1.0 + ramp_time) + 1.0 / (ramp_time + 1e-6))
        medians.append(effective)
    medians = np.array(medians)
    return np.all(np.diff(medians) <= medians[:-1] * 0.1 + 1e-6)




def run_self_tests() -> bool:
    geom = GeometryParams(num_z=128)
    field = FieldParams()
    cfg = CreationConfig(n_steps=60, dt=0.1, k_eig=12, epsilon_final=0.02, ramp="linear")
    tests = {
        "KG skew-Hermitian": _self_test_kg_inner_product(),
        "Bogoliubov identity": _self_test_bogoliubov_identity(),
        "Adiabatic monotonicity": _self_test_adiabatic(cfg, geom, field),
    }
    for name, result in tests.items():
        print(f"[self-test] {name}: {'PASS' if result else 'FAIL'}")
    return all(tests.values())




# ---------------------------------------------------------------------------
# CLI utilities
# ---------------------------------------------------------------------------




def summarize_creation(payload: Dict[str, ArrayLike], sweeps: Dict[str, object], cfg: CreationConfig) -> Dict[str, object]:
    eta = payload["eta"]
    epsilon = payload["epsilon_t"]
    beta_median = payload["beta_median_t"]
    beta_max = payload["beta_max_t"]
    unit_errs = payload["unitarity_error_t"]
    omega_last = payload["omega_last"]
    beta2_last = payload["beta2_last"]
    lambda_cov = check_lambda_covariance(payload["bases"][-1]["modes"], eta[1] - eta[0])
    leak = leakage_proxy(payload["geometry_slices"][-1]["z"], payload["bases"][-1]["modes"], payload["geometry_slices"][-1]["weight_phi"])
    beta_total = float(np.sum(np.abs(payload["beta_last"]) ** 2))


    summary = {
        "config": asdict(cfg),
        "eta": eta.tolist(),
        "epsilon_t": epsilon.tolist(),
        "beta_median_t": beta_median.tolist(),
        "beta_max_t": beta_max.tolist(),
        "omega_last": omega_last.tolist(),
        "max_beta2": float(np.max(beta_max)),
        "median_beta2": float(np.median(beta_median)),
        "norm_error": float(np.max(unit_errs)),
        "lambda_covariance": lambda_cov,
        "validation": sweeps,
        "energy_balance_error": float(payload["energy_balance_error"]),
        "created_energy": float(payload["created_energy"]),
        "delta_T00": float(payload["delta_T00"]),
        "leakage_proxy": float(leak),
        "beta_total": beta_total,
    }
    return summary




def save_artifacts(summary: Dict[str, object], payload: Dict[str, ArrayLike], outdir: Path) -> None:
    outdir.mkdir(parents=True, exist_ok=True)
    save_npz(
        outdir / "beta_time_series.npz",
        eta=np.array(summary["eta"]),
        epsilon=np.array(summary["epsilon_t"]),
        beta_median=np.array(summary["beta_median_t"]),
        beta_max=np.array(summary["beta_max_t"]),
    )
    save_plot_series(
        outdir / "beta_time_series.png",
        np.array(summary["eta"]),
        np.array(summary["epsilon_t"]),
        np.array(summary["beta_median_t"]),
        np.array(summary["beta_max_t"]),
    )
    with (outdir / "creation_summary.json").open("w", encoding="utf-8") as fh:
        json.dump(summary, fh, indent=2)
    write_markdown_report(outdir / "phase3_creation.md", summary)




# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------




def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Phase-3 KG particle creation harness")
    parser.add_argument("--run", choices=["creation"], help="Run type", required=False)
    parser.add_argument("--ramp", choices=["quench", "linear", "cos"], default="linear")
    parser.add_argument("--ramp-time", type=float, default=10.0)
    parser.add_argument("--epsilon", type=float, default=0.05)
    parser.add_argument("--k-eig", type=int, default=40)
    parser.add_argument("--dt", type=float, default=0.05)
    parser.add_argument("--n-steps", type=int, default=400)
    parser.add_argument("--outdir", type=str, default="outputs/phase3_particle_creation")
    parser.add_argument("--seed", type=int, default=0)
    parser.add_argument("--do-sweeps", action="store_true")
    parser.add_argument("--self-test", action="store_true")
    args = parser.parse_args(argv)


    if args.self_test:
        ok = run_self_tests()
        return 0 if ok else 1


    if args.run != "creation":
        parser.error("--run creation is the supported workflow")


    cfg = CreationConfig(
        ramp=args.ramp,
        ramp_time=args.ramp_time,
        epsilon_final=args.epsilon,
        k_eig=args.k_eig,
        dt=args.dt,
        n_steps=args.n_steps,
        method="leapfrog",
        seed=args.seed,
        outdir=args.outdir,
    )
    geom = GeometryParams()
    field = FieldParams()


    payload = compute_beta_time_series(cfg, geom, field)
    sweeps = {"absorber": [], "domain": [], "leakage_beta_corr": 0.0}
    if args.do_sweeps:
        sweeps = run_sweeps(payload, ValidationConfig())
    summary = summarize_creation(payload, sweeps, cfg)
    save_artifacts(summary, payload, Path(cfg.outdir))


    corr_value = sweeps.get("leakage_beta_corr", 0.0)
    print(
        "[Phase-3 Creation] "
        f"ramp={cfg.ramp} t={cfg.n_steps * cfg.dt:.1f} "
        f"maxβ²={summary['max_beta2']:.3e} medianβ²={summary['median_beta2']:.3e} "
        f"unit_err={summary['norm_error']:.3e} corr(leak,Σβ²)={corr_value:.3f}"
    )


    return 0




if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())


"""
=================================================================================
RESULTS


outputs/phase3_particle_creation/phase3_creation.md




# Phase-3 KG Particle Creation


## Configuration
```json
{
  "ramp": "linear",
  "ramp_time": 20.0,
  "epsilon_final": 0.05,
  "k_eig": 40,
  "dt": 0.05,
  "n_steps": 400,
  "method": "leapfrog",
  "seed": 1,
  "outdir": "outputs/phase3_particle_creation"
}
```


## Key metrics
* max |β|²: 2.0781e+15
* median |β|²: 3.0011e-03
* max unitarity error: 4.2961e+16
* leakage/β correlation: 1.000


## λ-covariance
Mean overlap: 3.594e-01, max overlap: 1.299e+00, compared: 36


## Validation sweeps
### Absorber
* absorber=0.0: energy_balance_error=0.000e+00
* absorber=0.2: energy_balance_error=0.000e+00
* absorber=0.4: energy_balance_error=0.000e+00


### Domain length
* domain_length=256: leakage_proxy=2.936e-30
* domain_length=384: leakage_proxy=1.440e-01
* domain_length=512: leakage_proxy=6.413e-01




=================================================================================
RESULTS


outputs/phase3_particle_creation/creation_summary.json


{
  "config": {
    "ramp": "linear",
    "ramp_time": 20.0,
    "epsilon_final": 0.05,
    "k_eig": 40,
    "dt": 0.05,
    "n_steps": 400,
    "method": "leapfrog",
    "seed": 1,
    "outdir": "outputs/phase3_particle_creation"
  },
  "eta": [
    0.0,
    0.05000000000000001,
    0.10000000000000002,
    0.15000000000000002,
    0.20000000000000004,
    0.25000000000000006,
    0.30000000000000004,
    0.3500000000000001,
    0.4000000000000001,
    0.45000000000000007,
    0.5000000000000001,
    0.5500000000000002,
    0.6000000000000001,
    0.6500000000000001,
    0.7000000000000002,
    0.7500000000000001,
    0.8000000000000002,
    0.8500000000000002,
    0.9000000000000001,
    0.9500000000000002,
    1.0000000000000002,
    1.0500000000000003,
    1.1000000000000003,
    1.1500000000000001,
    1.2000000000000002,
    1.2500000000000002,
    1.3000000000000003,
    1.3500000000000003,
    1.4000000000000004,
    1.4500000000000002,
    1.5000000000000002,
    1.5500000000000003,
    1.6000000000000003,
    1.6500000000000004,
    1.7000000000000004,
    1.7500000000000004,
    1.8000000000000003,
    1.8500000000000003,
    1.9000000000000004,
    1.9500000000000004,
    2.0000000000000004,
    2.0500000000000003,
    2.1000000000000005,
    2.1500000000000004,
    2.2000000000000006,
    2.2500000000000004,
    2.3000000000000003,
    2.3500000000000005,
    2.4000000000000004,
    2.4500000000000006,
    2.5000000000000004,
    2.5500000000000007,
    2.6000000000000005,
    2.6500000000000004,
    2.7000000000000006,
    2.7500000000000004,
    2.8000000000000007,
    2.8500000000000005,
    2.9000000000000004,
    2.9500000000000006,
    3.0000000000000004,
    3.0500000000000007,
    3.1000000000000005,
    3.150000000000001,
    3.2000000000000006,
    3.2500000000000004,
    3.3000000000000007,
    3.3500000000000005,
    3.400000000000001,
    3.4500000000000006,
    3.500000000000001,
    3.5500000000000007,
    3.6000000000000005,
    3.650000000000001,
    3.7000000000000006,
    3.750000000000001,
    3.8000000000000007,
    3.8500000000000005,
    3.900000000000001,
    3.9500000000000006,
    4.000000000000001,
    4.050000000000001,
    4.1000000000000005,
    4.150000000000001,
    4.200000000000001,
    4.250000000000001,
    4.300000000000001,
    4.3500000000000005,
    4.400000000000001,
    4.450000000000001,
    4.500000000000001,
    4.550000000000001,
    4.6000000000000005,
    4.650000000000001,
    4.700000000000001,
    4.750000000000001,
    4.800000000000001,
    4.8500000000000005,
    4.900000000000001,
    4.950000000000001,
    5.000000000000001,
    5.050000000000001,
    5.100000000000001,
    5.150000000000001,
    5.200000000000001,
    5.250000000000001,
    5.300000000000001,
    5.350000000000001,
    5.400000000000001,
    5.450000000000001,
    5.500000000000001,
    5.550000000000001,
    5.600000000000001,
    5.650000000000001,
    5.700000000000001,
    5.750000000000001,
    5.800000000000001,
    5.850000000000001,
    5.900000000000001,
    5.950000000000001,
    6.000000000000001,
    6.050000000000002,
    6.100000000000001,
    6.150000000000001,
    6.200000000000001,
    6.250000000000001,
    6.300000000000002,
    6.350000000000001,
    6.400000000000001,
    6.450000000000001,
    6.500000000000001,
    6.550000000000002,
    6.600000000000001,
    6.650000000000001,
    6.700000000000001,
    6.750000000000001,
    6.800000000000002,
    6.850000000000001,
    6.900000000000001,
    6.950000000000001,
    7.000000000000002,
    7.050000000000002,
    7.100000000000001,
    7.150000000000001,
    7.200000000000001,
    7.250000000000002,
    7.300000000000002,
    7.350000000000001,
    7.400000000000001,
    7.450000000000001,
    7.500000000000002,
    7.550000000000002,
    7.600000000000001,
    7.650000000000001,
    7.700000000000001,
    7.750000000000002,
    7.800000000000002,
    7.850000000000001,
    7.900000000000001,
    7.950000000000002,
    8.000000000000002,
    8.05,
    8.100000000000001,
    8.150000000000002,
    8.200000000000001,
    8.250000000000002,
    8.300000000000002,
    8.350000000000001,
    8.400000000000002,
    8.450000000000001,
    8.500000000000002,
    8.550000000000002,
    8.600000000000001,
    8.650000000000002,
    8.700000000000001,
    8.750000000000002,
    8.800000000000002,
    8.850000000000001,
    8.900000000000002,
    8.950000000000001,
    9.000000000000002,
    9.050000000000002,
    9.100000000000001,
    9.150000000000002,
    9.200000000000001,
    9.250000000000002,
    9.300000000000002,
    9.350000000000001,
    9.400000000000002,
    9.450000000000001,
    9.500000000000002,
    9.550000000000002,
    9.600000000000001,
    9.650000000000002,
    9.700000000000001,
    9.750000000000002,
    9.800000000000002,
    9.850000000000001,
    9.900000000000002,
    9.950000000000001,
    10.000000000000002,
    10.050000000000002,
    10.100000000000001,
    10.150000000000002,
    10.200000000000003,
    10.250000000000002,
    10.300000000000002,
    10.350000000000001,
    10.400000000000002,
    10.450000000000003,
    10.500000000000002,
    10.550000000000002,
    10.600000000000001,
    10.650000000000002,
    10.700000000000003,
    10.750000000000002,
    10.800000000000002,
    10.850000000000001,
    10.900000000000002,
    10.950000000000003,
    11.000000000000002,
    11.050000000000002,
    11.100000000000001,
    11.150000000000002,
    11.200000000000003,
    11.250000000000002,
    11.300000000000002,
    11.350000000000001,
    11.400000000000002,
    11.450000000000003,
    11.500000000000002,
    11.550000000000002,
    11.600000000000001,
    11.650000000000002,
    11.700000000000003,
    11.750000000000002,
    11.800000000000002,
    11.850000000000001,
    11.900000000000002,
    11.950000000000003,
    12.000000000000002,
    12.050000000000002,
    12.100000000000003,
    12.150000000000002,
    12.200000000000003,
    12.250000000000002,
    12.300000000000002,
    12.350000000000003,
    12.400000000000002,
    12.450000000000003,
    12.500000000000002,
    12.550000000000002,
    12.600000000000003,
    12.650000000000002,
    12.700000000000003,
    12.750000000000002,
    12.800000000000002,
    12.850000000000003,
    12.900000000000002,
    12.950000000000003,
    13.000000000000002,
    13.050000000000002,
    13.100000000000003,
    13.150000000000002,
    13.200000000000003,
    13.250000000000002,
    13.300000000000002,
    13.350000000000003,
    13.400000000000002,
    13.450000000000003,
    13.500000000000002,
    13.550000000000002,
    13.600000000000003,
    13.650000000000002,
    13.700000000000003,
    13.750000000000004,
    13.800000000000002,
    13.850000000000003,
    13.900000000000002,
    13.950000000000003,
    14.000000000000004,
    14.050000000000002,
    14.100000000000003,
    14.150000000000002,
    14.200000000000003,
    14.250000000000004,
    14.300000000000002,
    14.350000000000003,
    14.400000000000002,
    14.450000000000003,
    14.500000000000004,
    14.550000000000002,
    14.600000000000003,
    14.650000000000002,
    14.700000000000003,
    14.750000000000004,
    14.800000000000002,
    14.850000000000003,
    14.900000000000002,
    14.950000000000003,
    15.000000000000004,
    15.050000000000002,
    15.100000000000003,
    15.150000000000002,
    15.200000000000003,
    15.250000000000004,
    15.300000000000002,
    15.350000000000003,
    15.400000000000002,
    15.450000000000003,
    15.500000000000004,
    15.550000000000002,
    15.600000000000003,
    15.650000000000004,
    15.700000000000003,
    15.750000000000004,
    15.800000000000002,
    15.850000000000003,
    15.900000000000004,
    15.950000000000003,
    16.000000000000004,
    16.050000000000004,
    16.1,
    16.150000000000002,
    16.200000000000003,
    16.250000000000004,
    16.300000000000004,
    16.35,
    16.400000000000002,
    16.450000000000003,
    16.500000000000004,
    16.550000000000004,
    16.600000000000005,
    16.650000000000002,
    16.700000000000003,
    16.750000000000004,
    16.800000000000004,
    16.850000000000005,
    16.900000000000002,
    16.950000000000003,
    17.000000000000004,
    17.050000000000004,
    17.100000000000005,
    17.150000000000002,
    17.200000000000003,
    17.250000000000004,
    17.300000000000004,
    17.350000000000005,
    17.400000000000002,
    17.450000000000003,
    17.500000000000004,
    17.550000000000004,
    17.600000000000005,
    17.650000000000002,
    17.700000000000003,
    17.750000000000004,
    17.800000000000004,
    17.850000000000005,
    17.900000000000002,
    17.950000000000003,
    18.000000000000004,
    18.050000000000004,
    18.100000000000005,
    18.150000000000002,
    18.200000000000003,
    18.250000000000004,
    18.300000000000004,
    18.350000000000005,
    18.400000000000002,
    18.450000000000003,
    18.500000000000004,
    18.550000000000004,
    18.600000000000005,
    18.650000000000002,
    18.700000000000003,
    18.750000000000004,
    18.800000000000004,
    18.850000000000005,
    18.900000000000002,
    18.950000000000003,
    19.000000000000004,
    19.050000000000004,
    19.100000000000005,
    19.150000000000002,
    19.200000000000003,
    19.250000000000004,
    19.300000000000004,
    19.350000000000005,
    19.400000000000002,
    19.450000000000003,
    19.500000000000004,
    19.550000000000004,
    19.600000000000005,
    19.650000000000002,
    19.700000000000003,
    19.750000000000004,
    19.800000000000004,
    19.850000000000005,
    19.900000000000002,
    19.950000000000003
  ],
  "epsilon_t": [
    0.0,
    0.00012500000000000003,
    0.00025000000000000006,
    0.0003750000000000001,
    0.0005000000000000001,
    0.0006250000000000001,
    0.0007500000000000002,
    0.0008750000000000003,
    0.0010000000000000002,
    0.0011250000000000001,
    0.0012500000000000002,
    0.0013750000000000004,
    0.0015000000000000005,
    0.0016250000000000006,
    0.0017500000000000007,
    0.0018750000000000004,
    0.0020000000000000005,
    0.0021250000000000006,
    0.0022500000000000003,
    0.0023750000000000004,
    0.0025000000000000005,
    0.0026250000000000006,
    0.0027500000000000007,
    0.002875000000000001,
    0.003000000000000001,
    0.003125000000000001,
    0.003250000000000001,
    0.0033750000000000013,
    0.0035000000000000014,
    0.0036250000000000006,
    0.0037500000000000007,
    0.003875000000000001,
    0.004000000000000001,
    0.004125000000000001,
    0.004250000000000001,
    0.004375000000000001,
    0.0045000000000000005,
    0.004625000000000001,
    0.004750000000000001,
    0.004875000000000001,
    0.005000000000000001,
    0.005125000000000001,
    0.005250000000000001,
    0.005375000000000001,
    0.005500000000000001,
    0.0056250000000000015,
    0.005750000000000002,
    0.005875000000000002,
    0.006000000000000002,
    0.006125000000000002,
    0.006250000000000002,
    0.006375000000000002,
    0.006500000000000002,
    0.006625000000000001,
    0.0067500000000000025,
    0.006875000000000001,
    0.007000000000000003,
    0.007125000000000001,
    0.007250000000000001,
    0.007375000000000001,
    0.0075000000000000015,
    0.007625000000000002,
    0.007750000000000002,
    0.007875000000000002,
    0.008000000000000002,
    0.008125000000000002,
    0.008250000000000002,
    0.008375000000000002,
    0.008500000000000002,
    0.008625000000000002,
    0.008750000000000003,
    0.008875000000000003,
    0.009000000000000001,
    0.009125000000000003,
    0.009250000000000001,
    0.009375000000000003,
    0.009500000000000001,
    0.009625000000000002,
    0.009750000000000002,
    0.009875000000000002,
    0.010000000000000002,
    0.010125000000000002,
    0.010250000000000002,
    0.010375000000000004,
    0.010500000000000002,
    0.010625000000000002,
    0.010750000000000003,
    0.010875000000000003,
    0.011000000000000003,
    0.011125000000000003,
    0.011250000000000003,
    0.011375000000000003,
    0.011500000000000003,
    0.011625000000000003,
    0.011750000000000003,
    0.011875000000000004,
    0.012000000000000004,
    0.012125000000000002,
    0.012250000000000004,
    0.012375000000000004,
    0.012500000000000004,
    0.012625000000000004,
    0.012750000000000004,
    0.012875000000000004,
    0.013000000000000005,
    0.013125000000000005,
    0.013250000000000001,
    0.013375000000000005,
    0.013500000000000005,
    0.013625000000000005,
    0.013750000000000002,
    0.013875000000000002,
    0.014000000000000005,
    0.014125000000000006,
    0.014250000000000002,
    0.014375000000000002,
    0.014500000000000002,
    0.014625000000000006,
    0.014750000000000003,
    0.014875000000000003,
    0.015000000000000003,
    0.015125000000000006,
    0.015250000000000003,
    0.015375000000000003,
    0.015500000000000003,
    0.015625000000000003,
    0.015750000000000004,
    0.015875000000000004,
    0.016000000000000004,
    0.016125000000000004,
    0.016250000000000004,
    0.016375000000000004,
    0.016500000000000004,
    0.016625000000000004,
    0.016750000000000004,
    0.016875,
    0.017000000000000005,
    0.017125000000000005,
    0.017250000000000005,
    0.017375,
    0.017500000000000005,
    0.017625000000000005,
    0.017750000000000005,
    0.017875000000000002,
    0.018000000000000002,
    0.018125000000000006,
    0.018250000000000006,
    0.018375000000000002,
    0.018500000000000003,
    0.018625000000000003,
    0.018750000000000006,
    0.018875000000000003,
    0.019000000000000003,
    0.019125000000000003,
    0.019250000000000003,
    0.019375000000000003,
    0.019500000000000003,
    0.019625000000000004,
    0.019750000000000004,
    0.019875000000000004,
    0.020000000000000004,
    0.020125000000000004,
    0.020250000000000004,
    0.020375000000000004,
    0.020500000000000004,
    0.020625000000000004,
    0.020750000000000008,
    0.020875000000000005,
    0.021000000000000005,
    0.021125000000000005,
    0.021250000000000005,
    0.021375000000000005,
    0.021500000000000005,
    0.021625000000000005,
    0.021750000000000005,
    0.021875000000000006,
    0.022000000000000006,
    0.022125000000000006,
    0.022250000000000006,
    0.022375000000000006,
    0.022500000000000006,
    0.022625000000000006,
    0.022750000000000006,
    0.022875000000000006,
    0.023000000000000007,
    0.023125000000000007,
    0.023250000000000007,
    0.023375000000000007,
    0.023500000000000007,
    0.023625000000000004,
    0.023750000000000007,
    0.023875000000000007,
    0.024000000000000007,
    0.024125000000000008,
    0.024250000000000004,
    0.024375000000000008,
    0.024500000000000008,
    0.024625000000000005,
    0.024750000000000008,
    0.024875000000000005,
    0.02500000000000001,
    0.02512500000000001,
    0.02525000000000001,
    0.025375000000000005,
    0.02550000000000001,
    0.025625000000000005,
    0.02575000000000001,
    0.025875000000000006,
    0.02600000000000001,
    0.02612500000000001,
    0.02625000000000001,
    0.026375000000000006,
    0.026500000000000003,
    0.026625000000000006,
    0.02675000000000001,
    0.026875000000000007,
    0.02700000000000001,
    0.027125000000000007,
    0.02725000000000001,
    0.027375000000000007,
    0.027500000000000004,
    0.027625000000000007,
    0.027750000000000004,
    0.027875000000000007,
    0.02800000000000001,
    0.028125000000000008,
    0.02825000000000001,
    0.028375000000000008,
    0.028500000000000004,
    0.028625000000000008,
    0.028750000000000005,
    0.02887500000000001,
    0.029000000000000005,
    0.02912500000000001,
    0.029250000000000012,
    0.02937500000000001,
    0.029500000000000005,
    0.029625000000000002,
    0.029750000000000006,
    0.02987500000000001,
    0.030000000000000006,
    0.03012500000000001,
    0.030250000000000013,
    0.03037500000000001,
    0.030500000000000006,
    0.030625000000000003,
    0.030750000000000006,
    0.03087500000000001,
    0.031000000000000007,
    0.03112500000000001,
    0.03125000000000001,
    0.03137500000000001,
    0.03150000000000001,
    0.03162500000000001,
    0.03175000000000001,
    0.03187500000000001,
    0.03200000000000001,
    0.03212500000000001,
    0.03225000000000001,
    0.03237500000000001,
    0.03250000000000001,
    0.03262500000000001,
    0.03275000000000001,
    0.03287500000000001,
    0.03300000000000001,
    0.03312500000000001,
    0.03325000000000001,
    0.03337500000000001,
    0.03350000000000001,
    0.03362500000000001,
    0.03375,
    0.03387500000000001,
    0.03400000000000001,
    0.03412500000000001,
    0.03425000000000001,
    0.03437500000000001,
    0.03450000000000001,
    0.03462500000000001,
    0.03475,
    0.03487500000000001,
    0.03500000000000001,
    0.03512500000000001,
    0.03525000000000001,
    0.03537500000000001,
    0.03550000000000001,
    0.03562500000000001,
    0.035750000000000004,
    0.03587500000000001,
    0.036000000000000004,
    0.03612500000000001,
    0.03625000000000001,
    0.03637500000000001,
    0.03650000000000001,
    0.03662500000000001,
    0.036750000000000005,
    0.03687500000000001,
    0.037000000000000005,
    0.03712500000000001,
    0.037250000000000005,
    0.03737500000000001,
    0.03750000000000001,
    0.03762500000000001,
    0.037750000000000006,
    0.037875000000000006,
    0.038000000000000006,
    0.03812500000000001,
    0.038250000000000006,
    0.03837500000000001,
    0.038500000000000006,
    0.038625000000000013,
    0.03875000000000001,
    0.03887500000000001,
    0.03900000000000001,
    0.039125000000000014,
    0.03925000000000001,
    0.039375000000000014,
    0.03950000000000001,
    0.039625000000000014,
    0.03975000000000001,
    0.03987500000000001,
    0.04000000000000001,
    0.040125000000000015,
    0.04025000000000001,
    0.04037500000000001,
    0.04050000000000001,
    0.040625000000000015,
    0.04075000000000001,
    0.04087500000000001,
    0.04100000000000001,
    0.04112500000000001,
    0.04125000000000001,
    0.041375000000000016,
    0.041500000000000016,
    0.04162500000000001,
    0.04175000000000001,
    0.04187500000000001,
    0.04200000000000001,
    0.04212500000000002,
    0.04225000000000001,
    0.04237500000000001,
    0.04250000000000001,
    0.04262500000000002,
    0.04275000000000001,
    0.04287500000000001,
    0.04300000000000001,
    0.04312500000000001,
    0.04325000000000001,
    0.04337500000000002,
    0.04350000000000001,
    0.04362500000000001,
    0.04375000000000001,
    0.04387500000000001,
    0.04400000000000001,
    0.044125000000000004,
    0.04425000000000001,
    0.04437500000000001,
    0.04450000000000001,
    0.04462500000000002,
    0.04475000000000001,
    0.04487500000000001,
    0.04500000000000001,
    0.04512500000000001,
    0.04525000000000001,
    0.045375000000000006,
    0.04550000000000001,
    0.04562500000000001,
    0.04575000000000001,
    0.04587500000000001,
    0.04600000000000001,
    0.046125000000000006,
    0.04625000000000001,
    0.04637500000000001,
    0.046500000000000014,
    0.04662500000000001,
    0.046750000000000014,
    0.046875000000000014,
    0.047000000000000014,
    0.047125000000000014,
    0.04725000000000001,
    0.04737500000000001,
    0.047500000000000014,
    0.047625000000000015,
    0.047750000000000015,
    0.04787500000000001,
    0.048000000000000015,
    0.04812500000000001,
    0.048250000000000015,
    0.048375000000000015,
    0.04850000000000001,
    0.04862500000000001,
    0.048750000000000016,
    0.048875000000000016,
    0.049000000000000016,
    0.04912500000000001,
    0.04925000000000001,
    0.04937500000000001,
    0.049500000000000016,
    0.049625000000000016,
    0.04975000000000001,
    0.04987500000000001
  ],
  "beta_median_t": [
    0.0,
    0.0010399960593838443,
    0.00031670297963028307,
    0.011800563180274642,
    0.11402548367801672,
    0.003680845656404116,
    0.08678575599554367,
    0.01669042314272031,
    0.0009931911179113851,
    0.057601938672444765,
    0.056062393948860006,
    0.00020122065404750902,
    0.0005032302295206721,
    0.014597212298493643,
    0.04563654282333566,
    0.035565414742448447,
    2.108116850047908,
    0.331565795194512,
    0.023112439740817715,
    0.005030978223588303,
    0.14764343526823337,
    112.6370484775669,
    977.7903640010161,
    0.025074718593327976,
    0.0004277022313101272,
    0.050243362784362276,
    0.38354334708341753,
    0.03005275102270193,
    0.1455253722658274,
    0.004218640943220182,
    0.0011052254855217992,
    0.0006019005295989118,
    0.0011327816206292791,
    0.0015821401615540766,
    0.0035148949341393346,
    0.005327278747206329,
    0.5568259982461194,
    0.00024057387534844187,
    0.007084610132978939,
    0.02617636531208806,
    0.0006189703946719987,
    0.0006028039160485984,
    0.0010163783153828909,
    0.00033627005007220474,
    0.0004926238575489825,
    0.011976895406095178,
    0.00412947373794144,
    0.00027814676755338777,
    0.0007992833418209704,
    0.0008832289996178635,
    0.0011051071855084412,
    0.0009576754634353257,
    0.19662400836837,
    38.8626106004854,
    0.1327441888293846,
    0.003069723963749719,
    0.016407326779735963,
    0.003188654337477762,
    6.033033974884373,
    6.848766143189535,
    0.648503945100356,
    0.0725145293316824,
    0.010396658847333328,
    10.125859020966528,
    184.6477514822423,
    0.09191840341135875,
    1288.7533445065449,
    558164.8501671994,
    0.011582682230820204,
    0.0249526183751809,
    0.0005668586736024476,
    0.00028397825817020076,
    0.0015761514597508054,
    0.0009810260787698466,
    0.0007765586663029779,
    0.0037882973197770333,
    0.006679549581129323,
    0.0028789968544902277,
    0.0003807265303409852,
    0.0008631038272477841,
    0.0014109333572307407,
    0.015270023827537518,
    0.33613800629164076,
    0.2360522903414365,
    0.24155407330050788,
    0.004531577412636389,
    0.5462285742495567,
    0.0002967009746958966,
    0.0016795204460834752,
    0.004594434507970096,
    0.003902498082000156,
    0.0015030217626779887,
    0.00624433498244642,
    0.027016386248792247,
    0.00019036208094171182,
    0.0018157890836470953,
    0.0012797834358355955,
    0.023814794669041107,
    0.026814016278276055,
    0.0011547435867719866,
    0.0005203933797718497,
    0.0031556944301903292,
    0.007903972133365704,
    1.5292958353779689,
    26733.875389668363,
    0.000961730806397644,
    0.0009464971490885286,
    0.0007101766678005014,
    0.0006805450183332724,
    0.010769896805078387,
    0.04886127934620818,
    0.000423624382360762,
    0.0015092744375926055,
    0.011465955762150907,
    0.003173458195405305,
    0.00045728227577040005,
    0.009408260720983188,
    0.0068829197294746815,
    0.0004335803793629766,
    0.000467311162257217,
    0.0012242466303510181,
    0.001331673673400239,
    0.001867390054631662,
    0.028169844787889625,
    0.0012769472984378411,
    0.002261220968337083,
    0.003804610033653584,
    0.0013499753928150745,
    0.1262750741398099,
    12.283572992993165,
    0.0057148186899084255,
    0.0011855573360330242,
    0.002941469272219468,
    0.04465438656760316,
    0.041239720189633414,
    0.0008067425697751156,
    0.0002520416084986335,
    0.0006343343837847174,
    0.005372879379480686,
    0.003205281155214521,
    0.000287958922657928,
    0.00022061347548897915,
    0.0007354318077261405,
    0.0006322953515269287,
    0.0005438160022804659,
    0.0013141717332454121,
    0.0007251185928815829,
    0.0003220182012597647,
    0.0002452455131316683,
    0.0017297456236545878,
    0.0012984271529977818,
    0.00042094816666124934,
    0.00047533692961671285,
    0.0006013070632092977,
    0.004315943383673773,
    0.1503162877966259,
    0.6837856278200027,
    0.0008634367427762973,
    0.00052680777941628,
    0.007502586584259079,
    0.08451939292971083,
    0.31595068018568123,
    0.0031492387200366193,
    0.013971774529008572,
    0.21419417917524786,
    0.14150923194553686,
    0.008208287030123981,
    0.08740406794570973,
    0.006692942053170903,
    0.004705767484549672,
    0.0009372536344149625,
    0.0006112057235669857,
    0.007856425354888707,
    0.8842371147477697,
    0.006745689238196345,
    0.006734107796948354,
    0.00120988172485017,
    0.0001596822460654411,
    0.0009541180613917054,
    0.0015963236313225114,
    0.0007001623869410522,
    0.029557506848299928,
    0.08339821985514498,
    0.039460116100395445,
    0.0007968817663507706,
    0.0013818440770996141,
    0.01679654655132878,
    0.011436918019305443,
    0.0002228159279431825,
    0.00029859082861979615,
    0.0002499003295813153,
    0.0003381391985975678,
    0.0003608027212222192,
    0.014750709465231215,
    0.016243169102147542,
    0.0008681897150401904,
    0.004029941881656942,
    0.0019289915798629338,
    0.0016234822704723371,
    0.0014072172359446953,
    0.0007139897125504309,
    0.003060789710908951,
    0.004211070780765542,
    0.01635363494655273,
    0.0026515643100046013,
    0.0004757337711001557,
    0.002818964941753486,
    0.00327103113768061,
    0.0014647247643835262,
    0.04148121039692106,
    0.26666744765234085,
    0.0013891597743468567,
    0.0003834766653871049,
    0.0014913025166928414,
    0.0016802889842768448,
    0.0007209679373547245,
    0.00041355237109057415,
    0.0017546653009363833,
    0.004660501071336841,
    0.002854315019846997,
    0.0017214129153242032,
    0.0016967234416946663,
    0.01381748862656438,
    0.05306570432129037,
    0.018745535435212055,
    0.08276127930983716,
    0.002231802078541549,
    0.030243193400739075,
    0.09067306820026752,
    0.0020148786514027363,
    0.014561694628679588,
    0.002850551271026608,
    0.015509102377450804,
    0.01822477450016602,
    0.0005875118185054822,
    0.0004565055897231974,
    0.0028843419175233753,
    0.0063988445193664915,
    0.0010275537432545892,
    0.0013945144001677636,
    0.0010392950823255637,
    0.0016015076613389277,
    0.001471029184321488,
    0.00029455504552773024,
    0.0027027118231626812,
    0.005092928317287999,
    0.0004807775407487621,
    0.0022315209746706388,
    0.011718517684034296,
    0.007859918252409972,
    0.001971351252895706,
    0.0006544380258591343,
    0.000522610571095516,
    0.002426058771003876,
    0.003273428537821225,
    0.002188028958226813,
    0.0020537188375119282,
    0.000778907305550975,
    0.00034819446373153117,
    0.0006404097069686038,
    0.001317550023276882,
    0.0004112726637774558,
    0.00033793101586911454,
    0.00012533534046716145,
    0.012078722924820338,
    0.8104235502968594,
    0.0025039711706863472,
    0.0015707831830141293,
    0.0006715666180586302,
    0.000518684338015049,
    0.004237809816017951,
    13.885139518296947,
    131.69587907807644,
    1.3326256752359678,
    0.3048229205845121,
    0.27475311695593674,
    0.0004213878931509094,
    2.5644814806819167,
    1.1192813252652003,
    0.0016643685112924438,
    0.008819995299770426,
    0.10789732949280981,
    0.019099614945149203,
    0.00046194845783978556,
    0.003533758389211737,
    0.003679196823091325,
    0.00651907431775008,
    1.6089749199561998,
    0.13519213454545412,
    0.0012482969003042529,
    0.0007774996519750117,
    0.0008965384298233301,
    0.0008327105768403683,
    0.0037978214219619244,
    0.0020357280306243456,
    0.0005995542745864115,
    0.5459901950140725,
    0.8854568967259406,
    6.3606844597087475,
    434622.9285136275,
    1543.1057504168734,
    0.0015991884588795937,
    0.0008870020157853119,
    0.0010738775138269888,
    0.009794860864985419,
    0.05404936560487574,
    0.0005179845901028017,
    0.00017631198929653552,
    0.0017565238093044744,
    0.0022455206531039893,
    0.0006093076443201269,
    0.00015380187858979726,
    0.0062067852606996115,
    0.02471941933206701,
    0.22487803545360002,
    0.11606176952872972,
    0.0012854476668308433,
    0.0008632133697848475,
    0.8777966060756681,
    85.90310629007695,
    0.0010234826928767079,
    0.00020264610604565122,
    0.0003445899273158597,
    0.001369185529900877,
    0.0005677095600779262,
    0.001910406943879496,
    0.4650903293722062,
    5.3492713136612515,
    79.3024967014466,
    0.03208145673311977,
    0.04826436385340273,
    0.005979778267511244,
    0.0012722686750089563,
    0.0005477620640734072,
    0.0003726184385398961,
    0.00033399319485042647,
    0.04167491940556893,
    0.4057843209899378,
    0.0005659346676288241,
    0.002580553297568187,
    0.0005981490582378996,
    0.0005963703212890127,
    0.004404925276701896,
    0.008713627616312055,
    0.0021619501527058594,
    0.0036352898222224758,
    0.0022593882900448143,
    0.0028556836287600344,
    0.004376493139205912,
    0.0016706829255769937,
    0.5029693508973351,
    2639.402411080841,
    0.0064081777149695845,
    0.0011194769351323647,
    0.0022436432807806652,
    0.0852071111803521,
    0.013170331060203051,
    0.0005235086961760015,
    0.0007650632535255704,
    0.0014485084553413764,
    0.45323209093361605,
    46.333310719555115,
    0.0003974853875125687,
    0.0022939864489240685,
    0.0016944901178883832,
    0.009495413454310962,
    0.14897322140562191,
    0.7440439204895546,
    15.339156776965142,
    0.04011802004342075,
    0.05880290720878087,
    0.06963662926915355,
    0.03399130970985251,
    0.0049614293155537,
    0.0012009546514621548,
    0.005689538971498617,
    0.054480234688789556,
    0.00027610883571147654,
    0.00025867138329873794,
    0.007301904427218285,
    0.0312195568349483,
    0.4054537251665482,
    23.247051096042632,
    0.02316535262941707,
    5.541102569154652e-05,
    0.0006023289709702248,
    0.0021617072274524307,
    0.005276328470640357,
    0.0019465698337773917,
    0.0004304058895174825,
    0.00035928787633725696,
    0.0006019956952962842,
    0.004627621844385733,
    0.0017843125390426024,
    0.0012399032150576031,
    1.179682248533476,
    14.12106029989371,
    0.008665480165800455,
    0.001549426876929674,
    0.0019440055601142314
  ],
  "beta_max_t": [
    0.0,
    285433.2110200599,
    0.08876935323618422,
    2.7635119415007465,
    41.28135644985567,
    42.83244143975488,
    27298.51739779153,
    1166.4838393900527,
    1.2647312966463384,
    26.26291691073537,
    379.76998682312797,
    0.052809320155339325,
    0.16280293672518806,
    176.69378572037377,
    3840.670430404915,
    22.491531150227882,
    1881.289103985146,
    67.57786911316302,
    35.22363659593639,
    62.021806222284,
    291.5316781093237,
    20037300.490170088,
    422024326231.9345,
    9587.285851249579,
    0.13616476052097473,
    35.67829910414444,
    647.8889234206237,
    1.527634845191794,
    21843.014604682518,
    106509.72797845479,
    0.31413241153222793,
    19.327233920980483,
    23.35219425663283,
    8.080778844050217,
    15.953914459937614,
    36.28914214630984,
    850484403.739392,
    0.4080910530758687,
    30.933588817476718,
    261.18913033684436,
    1.4370720543325806,
    0.22182944655935868,
    0.5237040040376468,
    1.0574432295317355,
    0.23969012153470418,
    91.3974365977034,
    258.9870240745928,
    0.042837819597710984,
    1.0602569239097486,
    0.8480870035839766,
    0.7064908711402461,
    0.24210003906529104,
    69.5557585739064,
    24957.694863367487,
    246.1906884808487,
    5.744803987657443,
    22.831637799396685,
    8.228382719195425,
    41053.5796146809,
    85296.50348147716,
    35796.35419269684,
    310.02851788669784,
    39235.40882911894,
    1213909.3529176982,
    526983308.8840352,
    3885.1490710106814,
    575963.6753756796,
    7808258574607.2,
    22.407894432100665,
    292.73223997429125,
    0.48483673165621255,
    0.30680994490017693,
    6.862174411681267,
    11.879456377000794,
    0.7346869904048171,
    1.6492344483703645,
    1323.2195689347782,
    746.727301059261,
    0.05034193271563254,
    0.1446157504538401,
    0.43860342258583523,
    535.0603412373644,
    2687.51835265345,
    291.3088385073031,
    619.9890748773882,
    3.081091386882227,
    343555970315.3806,
    0.21184329646100636,
    6.170226340805664,
    9.17545244552013,
    6.623514562868886,
    2.4903206244887715,
    2.5266710062123443,
    24.595106590859217,
    0.09467792975999165,
    0.9092101060128812,
    0.9955699931805254,
    5185.451842197678,
    3098.436159325399,
    0.5047242117782657,
    0.1308733685157744,
    2.103688815171364,
    13.974130317403567,
    6549.952561019768,
    7341312440908.171,
    0.4473580115449742,
    0.4365360884141636,
    0.30596115687851544,
    0.20611495586447912,
    157.56492765425804,
    387.3652675530086,
    0.2976784455330605,
    0.36597705819395654,
    49.56628287838701,
    189.98364675044277,
    0.09128616447377039,
    24.190975877637864,
    1149.1725740224063,
    0.17089336535602115,
    0.15770597864204788,
    23.65587502970174,
    43.990037470471094,
    0.5080686164096742,
    8.043979054921424,
    0.3456444038591881,
    3.380130658841696,
    1703216.9080711848,
    141.28092126011273,
    43.20337863572546,
    196165.02849988433,
    65.94112273013525,
    0.9613451660916372,
    103.43437210108269,
    77029.7868817265,
    778.3458221444996,
    0.15487266476571543,
    0.0414877204823369,
    0.11414580228812972,
    956990.8605595799,
    28599213.8081514,
    0.11116287376911729,
    0.13735567162185994,
    0.12192093229486967,
    0.1662155512192183,
    0.2611314427192215,
    0.5232554921362972,
    0.334567946437005,
    0.1927622276353238,
    0.061279408285746566,
    10.862955056947024,
    29.07736564740321,
    0.24113503283742913,
    0.10351568905933962,
    0.3020367993751433,
    45.49171890591308,
    214.20812605808865,
    43846.33190047461,
    0.5991055073079462,
    0.2967141037565722,
    6.748473925712174,
    177.43130926097118,
    3799.6686859087968,
    14.75209957134668,
    53.84947890805755,
    106.12121043287009,
    279.69751435493964,
    5.600727307974497,
    44.509605331960806,
    24.325260937158813,
    120.03156141936236,
    0.14514973643218607,
    0.3544454037205995,
    1.2020754119602426,
    1271160.6285791837,
    90.20333271296374,
    4.258918220481622,
    1.6038138183018642,
    0.13435153590181642,
    1.3880852747839778,
    1.3309656019667975,
    0.890105700102218,
    13.951950138852116,
    1937.5438452023386,
    21.859606297865984,
    2.7081867515851954,
    0.9640149194859554,
    1.5118654440386177,
    62.11828819361563,
    0.13685303839865173,
    0.2177157094200764,
    0.08411853575884867,
    0.05632397271721128,
    0.11234818063154195,
    801.1453963483456,
    740.047872555928,
    0.1665316901982581,
    8.493606251869773,
    14.551774770079117,
    0.5231996946007516,
    0.5048585975462707,
    0.5462826495256269,
    0.8991568362975031,
    1317375.3592468847,
    2694981586.985624,
    16122.79513783213,
    0.06701636697258263,
    0.5608977834344798,
    103.68511185879686,
    5.362442957104748,
    6.926405618164928,
    12758.651362443927,
    19011.22740831823,
    0.23963918926263386,
    0.2733618020585581,
    0.821632824802607,
    0.6308646773415993,
    0.17392258165139504,
    2.935991195980691,
    24993.105866511556,
    0.7815376688586207,
    0.21754866323056563,
    22.99334188736521,
    24.73856743929998,
    42.28362441917,
    19.781860092483324,
    213.2463543424479,
    9.923914327582304,
    37.904405576756794,
    192298870.05701408,
    17.706982200933513,
    249.91908594900374,
    1.559509518751567,
    69.01375189592753,
    3120.158545425569,
    0.3208643528052298,
    0.15833631842055357,
    4.1815296727597335,
    17.384837738916826,
    0.31981844483995353,
    0.2531463621586768,
    0.17869808775615298,
    99.10646710421204,
    670.4995406054995,
    0.04656150883907529,
    125.52904260956721,
    8.948717963080705,
    0.26549618700676286,
    0.7334840816099684,
    24.66407424982884,
    2.203271479984907,
    4.348499450667164,
    0.5791356736087315,
    0.2254041171786528,
    134.85428126093925,
    47503.16592322299,
    16.933785301283724,
    16.98736632060398,
    0.4567056911157355,
    0.21586301035916786,
    0.663630770982466,
    0.527636598588997,
    0.3464882187367638,
    0.11772486551593375,
    0.08802359308744662,
    3.977267164575675,
    273.7308748187756,
    0.6482740366528412,
    6.466296467480595,
    123.2906251562555,
    0.23553755271794696,
    8.346291324300855,
    1065236.7526342263,
    405886.2583619825,
    314137670.1353333,
    352.91559343392356,
    169.4034224905379,
    0.17282126587650562,
    413113.6450106784,
    1084096.780994105,
    5.613857099422215,
    225.17905817352354,
    22821.56844719272,
    12852.264540420669,
    1.446548849370765,
    77.61951710925663,
    90.95330495170892,
    4.270058507246792,
    4827660708.958372,
    587.1791481888527,
    2.84400012926526,
    1.774185518576304,
    1.5345671653748265,
    0.16311560395055674,
    1367.123595299124,
    3.132756876465934,
    0.25680909163605203,
    3501.5604421575717,
    12583.633398274425,
    5513.484541390724,
    2078138009036585.0,
    58928365271.760826,
    26.27522761392842,
    0.2628963751542873,
    0.45167555775601725,
    10.167348488225233,
    10517045.4511623,
    0.31445960918193716,
    0.10984433883668088,
    27.24018002541297,
    119.00188226595675,
    0.44595767726203445,
    0.4215362750079892,
    1801016.5667874475,
    25867764.756004184,
    171.32576161340273,
    744.8345666937751,
    0.2974651059078698,
    0.3617784925716503,
    594.8672025985906,
    489654064.34840685,
    0.11939456516320109,
    0.13358249453002222,
    0.692714141771172,
    0.4236483113186031,
    0.30750544371974087,
    3.415031575620889,
    258.37690969074663,
    49540.45269980905,
    176899567484.8203,
    85.1190480539894,
    518.0644377306415,
    333.5202639812637,
    0.4970083529730547,
    0.4051908878287589,
    0.7878180862566336,
    0.10096831048042018,
    10.834449431234843,
    451322.34402225533,
    0.18726974638378763,
    0.4017758058096716,
    0.5924143001256387,
    0.17382588074101346,
    10.321462378006736,
    7.5593266888256965,
    934.6441580869537,
    2894.6333758219516,
    2.8290726580639136,
    2.0124880879810596,
    43.71121532758014,
    95.02163988688326,
    2713.5921995687604,
    5643586940.026784,
    67.44707785734188,
    0.11197632254913795,
    1.0424486284463088,
    83464.76865657425,
    439345.4690813502,
    1.4177629268272331,
    0.20791844496060735,
    0.4331773542071491,
    4382.5738840101,
    1373283.7592555715,
    0.1384267029267221,
    0.40213430000287914,
    0.5628280521578353,
    1.1109840670533753,
    232.76529570900547,
    902.2845375286839,
    3547847986506.793,
    278.6507939114584,
    1787339.4541972566,
    1205744.5796271139,
    122.05872342207024,
    48.43480658656986,
    46.18168200445777,
    6.821177121666635,
    379.22526199925073,
    0.25198590626006995,
    0.12618152103321728,
    3.0387232534068094,
    81.89731933546824,
    566.4169840431099,
    8243441.541561154,
    388.91203282807777,
    0.15055523968406856,
    0.1026909167886456,
    12.720295489940941,
    23.15468349145237,
    0.5525133206327651,
    0.37784558546225555,
    0.12896238926648754,
    0.710896129119189,
    1.239210914677257,
    1.281124246867913,
    0.9101437656810238,
    30017.260831901047,
    93648426.3033899,
    2.150301236751414,
    2.2946332239494542,
    1.0486678366799822
  ],
  "omega_last": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.269050473489122,
    0.5505054037769502,
    0.7440889797681784,
    0.9334787035941325,
    1.1134213699274318,
    1.315168629346716,
    1.3865890180939808,
    1.5801164524549351,
    1.7315164438288018,
    1.7936315533796243,
    1.9546399108613668,
    2.04306852910617,
    2.1960657321572863,
    2.46590901406856,
    2.5795168051894395,
    2.7067013765052406,
    2.840519594001046,
    3.103613545113625,
    3.247882511447276,
    3.3316593649649877,
    3.472909745593643,
    3.615815786307484,
    3.842410169873177,
    3.9761251066896612,
    4.195889232702323,
    4.363686508594439,
    4.429361390029282,
    4.696470930123423,
    4.792099062211849,
    4.841792349559819
  ],
  "max_beta2": 2078138009036585.0,
  "median_beta2": 0.0030011294915642094,
  "norm_error": 4.296097514283373e+16,
  "lambda_covariance": {
    "mean_overlap": 0.35944035293064674,
    "max_overlap": 1.2990223457731471,
    "num_compared": 36
  },
  "validation": {
    "absorber": [
      {
        "absorber": 0.0,
        "energy_balance_error": 0.0
      },
      {
        "absorber": 0.2,
        "energy_balance_error": 0.0
      },
      {
        "absorber": 0.4,
        "energy_balance_error": 0.0
      }
    ],
    "domain": [
      {
        "domain_length": 256,
        "leakage_proxy": 2.9363584397311807e-30
      },
      {
        "domain_length": 384,
        "leakage_proxy": 0.14403982840540105
      },
      {
        "domain_length": 512,
        "leakage_proxy": 0.6413010494444398
      }
    ],
    "leakage_beta_corr": 1.0
  },
  "energy_balance_error": 0.0,
  "created_energy": 40.52299184138583,
  "delta_T00": 40.52299184138583,
  "leakage_proxy": 2.9363584397311807e-30,
  "beta_total": 17.2007894803274
}
"""






========================================================================

kg_scale_invariant_metric_enhanced_01.py

========================================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
kh_scale_invariance_metric_enhanced_01.py


VERBOSE INTRODUCTION
--------------------
This module implements a 1D axisymmetric, λ-scale-invariant geometry and a
Klein–Gordon (KG) particle-creation harness over that background. The geometry
is generated by integrating r'(z) = h(r) with h(r) = α r · (1 + ε cos(2π log_λ r))
(ε = 0 reduces to exact scale-invariance). From this background we construct the
discrete spatial KG operator for an azimuthal mode m_θ, compute instantaneous
positive-frequency mode bases, and evolve a time-dependent “ramp” of ε to
estimate Bogoliubov coefficients (α, β) between successive slices. These give a
proxy for particle creation (∑ ω_k |β_k|²) and a unitarity diagnostic
‖α†α − β†β − I‖₂.


Design goals:
 - Reproducibility and numerical safety (shape checks, conditioning, clipping).
 - Clean separation of concerns (geometry, operators, modes, transforms, driver).
 - No placeholders: all previously partial routines are completed.


Key references to your stack:
 - Geometry/profile integration and curvature proxy from your Phase-3 code.
 - KG inner product, orthonormalization, and instantaneous basis as in your
   “enhanced” metrics script.
 - Bogoliubov workflow and ramped ε schedule mirroring your creation harness.


Typical usage:
  $ python3 kh_scale_invariance_metric_enhanced_01.py --save


It will report max/median β², a unitarity error, and optionally save a JSON
summary and an NPZ with the β time-series.


Author: (derived and consolidated from your uploads)
"""


from __future__ import annotations


import argparse
import json
import math
import os
import sys
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Literal, Optional, Sequence, Tuple


import numpy as np
from numpy.typing import ArrayLike
from scipy.sparse import diags
from scipy.sparse.linalg import eigsh




# -----------------------------------------------------------------------------
# Dataclasses and configuration
# -----------------------------------------------------------------------------


RampKind = Literal["quench", "linear", "cos"]
TimeStepper = Literal["leapfrog", "crank_nicolson"]  # reserved (spatial-only here)


@dataclass
class GeometryParams:
    """Axisymmetric λ-scale-invariant geometry parameters."""
    lam: float = math.sqrt(6.0) / 2.0  # λ
    z_min: float = -10.0
    z_max: float = 10.0
    num_z: int = 1200
    r0: float = 1.0
    epsilon: float = 0.0  # ε modulation magnitude


    def copy_with(self, **updates: float) -> "GeometryParams":
        d = asdict(self)
        d.update(updates)
        return GeometryParams(**d)


    @property
    def dz(self) -> float:
        return (self.z_max - self.z_min) / max(self.num_z - 1, 1)




@dataclass
class FieldParams:
    """Field properties for the Klein–Gordon equation."""
    mu: float = 0.5
    xi: float = 0.0
    m_theta: int = 0
    k_eig: int = 40




@dataclass
class CreationConfig:
    """Run control for the time-dependent creation problem."""
    ramp: RampKind = "linear"
    ramp_time: float = 10.0
    epsilon_final: float = 0.05
    k_eig: int = 40
    dt: float = 0.05
    n_steps: int = 400
    method: TimeStepper = "leapfrog"
    outdir: str = "outputs/phase3_particle_creation"
    seed: int = 0
    absorber_strength: float = 0.0
    absorber_width: float = 2.0




@dataclass
class ValidationConfig:
    """Validation sweeps for absorbers and domain sizes."""
    absorber_settings: Sequence[float] = (0.0, 0.2, 0.4)
    domain_lengths: Sequence[float] = (20.0, 30.0, 40.0)  # z_max = -z_min = L




# -----------------------------------------------------------------------------
# Geometry and curvature proxies
# -----------------------------------------------------------------------------


def make_h_function(lam: float, epsilon: float = 0.0):
    """Return h(r) controlling dr/dz. ε=0 gives exact exponential profile."""
    alpha = math.log(lam)


    def h(r: float) -> float:
        if r <= 0.0:
            return 0.0
        base = alpha * r
        if epsilon == 0.0:
            return base
        x = math.log(r) / alpha            # x = ln r / ln λ
        return base * (1.0 + epsilon * math.cos(2.0 * math.pi * x))


    return h




def integrate_profile(params: GeometryParams) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Integrate r'(z) = h(r) and return (z, r(z), ρ(z), R(z)) where:
      ρ(z) = h(r) / (α r) and R ~ 2K with K ≈ -r''/r  (thin-shell proxy).
    """
    z = np.linspace(params.z_min, params.z_max, params.num_z)
    dz = z[1] - z[0]
    alpha = math.log(params.lam)
    h = make_h_function(params.lam, params.epsilon)


    r = np.empty_like(z)
    r[0] = params.r0
    for i in range(1, params.num_z):
        r[i] = max(1e-18, r[i - 1] + dz * h(r[i - 1]))


    # density index ρ and curvature proxy
    rho = np.array([h(rv) / (alpha * max(rv, 1e-18)) for rv in r])


    def h_prime(rv: float) -> float:
        if params.epsilon == 0.0 or rv <= 0.0:
            return alpha
        x = math.log(rv) / alpha
        # d/dr [α r (1 + ε cos(2πx))] with x = ln r / α
        return alpha * (1.0 + params.epsilon * math.cos(2.0 * math.pi * x)
                        - params.epsilon * (2.0 * math.pi) * math.sin(2.0 * math.pi * x) / alpha)


    rp = np.array([h(rv) for rv in r])
    hp = np.array([h_prime(rv) for rv in r])
    rpp = hp * rp
    with np.errstate(divide="ignore", invalid="ignore"):
        K = -rpp / np.clip(r, 1e-18, None)
        R = 2.0 * K
    return z, r, rho, R




# -----------------------------------------------------------------------------
# KG spatial operator and spectral modes
# -----------------------------------------------------------------------------


def build_kg_operator(z: np.ndarray, r: np.ndarray, R: np.ndarray, field: FieldParams):
    """
    Discrete KG operator A ≈ -[1/r ∂_z (r ∂_z)] + m² + ξR + m_θ² / r²
    with homogeneous boundary conditions at the ends (Dirichlet-like).
    """
    n = len(z)
    dz = z[1] - z[0]
    r_mid = 0.5 * (r[1:] + r[:-1])


    main = np.zeros(n)
    off_lower = np.zeros(n - 1)
    off_upper = np.zeros(n - 1)


    for i in range(1, n - 1):
        a_minus = r_mid[i - 1] / (r[i] * dz * dz)
        a_plus = r_mid[i] / (r[i] * dz * dz)
        main[i] = a_minus + a_plus
        off_lower[i - 1] = -a_minus
        off_upper[i] = -a_plus


    # simple boundary pins
    main[0] = 1.0
    main[-1] = 1.0


    ang_term = (field.m_theta ** 2) / np.clip(r ** 2, 1e-18, None)
    pot = ang_term + (field.mu ** 2 + field.xi * R)
    main += pot


    A = diags([off_lower, main, off_upper], offsets=[-1, 0, 1], format="csr")
    return A, pot




def compute_modes(A, k: int) -> Tuple[np.ndarray, np.ndarray]:
    """Return the k lowest eigenpairs of A (symmetric Hermitian)."""
    n = A.shape[0]
    k = max(1, min(k, n - 2))
    vals, vecs = eigsh(A, k=k, which="SA")
    order = np.argsort(vals)
    return vals[order], vecs[:, order]




def normalize_on_z(z: np.ndarray, u: np.ndarray) -> np.ndarray:
    """Normalize with respect to ∫ |u|² dz."""
    norm = np.trapezoid(np.real(u * np.conjugate(u)), z)
    norm = math.sqrt(max(norm, 1e-16))
    return u / norm




# -----------------------------------------------------------------------------
# KG inner product and instantaneous basis
# -----------------------------------------------------------------------------


def kg_inner_product(
    mode_a: Tuple[np.ndarray, np.ndarray],
    mode_b: Tuple[np.ndarray, np.ndarray],
    weight_phi: np.ndarray,
    weight_pi: Optional[np.ndarray] = None,
) -> complex:
    """
    Discrete KG inner product:
        (u, v)_KG = i ∫ (φ_u* π_v - π_u* φ_v) dΣ
    Here we use sqrt-weights for numerical stability.
    """
    w_pi = weight_pi if weight_pi is not None else weight_phi
    phi_a, pi_a = mode_a
    phi_b, pi_b = mode_b
    sqrt_w_phi = np.sqrt(weight_phi)
    sqrt_w_pi = np.sqrt(w_pi)
    term1 = np.vdot(sqrt_w_phi * phi_a, sqrt_w_phi * pi_b)
    term2 = np.vdot(sqrt_w_pi * pi_a, sqrt_w_pi * phi_b)
    return 1j * (term1 - term2)




def orthonormalize_modes(
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    weight_phi: np.ndarray,
    weight_pi: Optional[np.ndarray] = None,
    tol: float = 1e-12,
) -> Tuple[List[Tuple[np.ndarray, np.ndarray]], float]:
    """
    KG Gram–Schmidt with post SVD reconditioning. Returns (ortho_modes, cond#).
    """
    w_pi = weight_pi if weight_pi is not None else weight_phi
    ortho: List[Tuple[np.ndarray, np.ndarray]] = []


    for phi, pi in modes:
        phi = np.array(phi, dtype=np.complex128)
        pi = np.array(pi, dtype=np.complex128)


        for bphi, bpi in ortho:
            coeff = kg_inner_product((bphi, bpi), (phi, pi), weight_phi, w_pi)
            phi -= coeff * bphi
            pi  -= coeff * bpi


        norm = kg_inner_product((phi, pi), (phi, pi), weight_phi, w_pi)
        if abs(norm) < tol:
            continue


        # fix arbitrary overall phase and scale to +1 norm
        phase = np.exp(-0.5j * np.angle(norm))
        phi *= phase
        pi  *= phase
        norm = kg_inner_product((phi, pi), (phi, pi), weight_phi, w_pi)
        norm_real = float(norm.real)
        if norm_real < 0:
            phi = -phi
            pi  = -pi
            norm_real = -norm_real
        scale = math.sqrt(max(norm_real, tol))
        phi /= scale
        pi  /= scale
        ortho.append((phi, pi))


    if not ortho:
        return [], 1.0


    # Recheck orthonormality; apply whitening if needed
    gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
    for i, a in enumerate(ortho):
        for j, b in enumerate(ortho):
            gram[i, j] = kg_inner_product(a, b, weight_phi, w_pi)
    u, s, vh = np.linalg.svd(gram)
    cond = float(s[0] / max(s[-1], 1e-14))


    if cond > 1e8 or np.max(np.abs(gram - np.eye(len(ortho)))) > 1e-8:
        transform = u @ np.diag(1.0 / np.sqrt(np.clip(s, 1e-14, None))) @ vh
        new_ortho: List[Tuple[np.ndarray, np.ndarray]] = []
        for i in range(transform.shape[0]):
            phi = np.zeros_like(ortho[0][0])
            pi  = np.zeros_like(ortho[0][1])
            for coeff, (phi_b, pi_b) in zip(transform[i], ortho):
                phi += coeff * phi_b
                pi  += coeff * pi_b
            new_ortho.append((phi, pi))
        ortho = new_ortho


        gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
        for i, a in enumerate(ortho):
            for j, b in enumerate(ortho):
                gram[i, j] = kg_inner_product(a, b, weight_phi, w_pi)
        s = np.linalg.svd(gram, compute_uv=False)
        cond = float(s[0] / max(s[-1], 1e-14))


    return ortho, cond




def instantaneous_basis(
    z: np.ndarray,
    geo_slice: Dict[str, np.ndarray],
    field: FieldParams,
    k_eig: int,
) -> Dict[str, ArrayLike]:
    """
    Return the instantaneous positive-frequency basis on a slice:
      modes = {(φ_k, π_k) with π_k = -i ω_k φ_k}, orthonormal in KG sense.
    """
    A, _ = build_kg_operator(z, geo_slice["r"], geo_slice["R"], field)
    evals, modes = compute_modes(A, k_eig)
    omegas = np.sqrt(np.clip(evals, 0.0, None))


    kg_modes: List[Tuple[np.ndarray, np.ndarray]] = []
    for idx in range(len(omegas)):
        phi = normalize_on_z(z, modes[:, idx])
        pi  = -1j * omegas[idx] * phi
        kg_modes.append((phi, pi))


    ortho_modes, cond = orthonormalize_modes(kg_modes, geo_slice["weight_phi"], geo_slice["weight_pi"])


    gram = np.zeros((len(ortho_modes), len(ortho_modes)), dtype=np.complex128)
    for i, a in enumerate(ortho_modes):
        for j, b in enumerate(ortho_modes):
            gram[i, j] = kg_inner_product(a, b, geo_slice["weight_phi"], geo_slice["weight_pi"])


    return {
        "modes": ortho_modes,
        "omega": omegas[: len(ortho_modes)],
        "condition": cond,
        "gram": gram,
    }




# -----------------------------------------------------------------------------
# Bogoliubov transforms and diagnostics
# -----------------------------------------------------------------------------


def bogoliubov_coeffs(
    prev_basis: Dict[str, ArrayLike],
    curr_basis: Dict[str, ArrayLike],
    weight_phi: np.ndarray,
    weight_pi: Optional[np.ndarray] = None,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute Bogoliubov matrices α, β via KG inner products between the
    previous (+) basis and current (+/−) basis.
    """
    w_pi = weight_pi if weight_pi is not None else weight_phi
    prev_modes = prev_basis["modes"]
    curr_modes = curr_basis["modes"]
    n = min(len(prev_modes), len(curr_modes))
    alpha = np.zeros((n, n), dtype=np.complex128)
    beta  = np.zeros((n, n), dtype=np.complex128)


    for j in range(n):
        for k in range(n):
            # + with +
            alpha[j, k] = kg_inner_product(prev_modes[j], curr_modes[k], weight_phi, w_pi)
            # + with − (complex conjugate pair)
            neg_k = (np.conjugate(curr_modes[k][0]), np.conjugate(curr_modes[k][1]))
            beta[j, k]  = -kg_inner_product(prev_modes[j], neg_k, weight_phi, w_pi)


    return alpha, beta




def bogoliubov_unitarity_error(alpha: np.ndarray, beta: np.ndarray) -> float:
    """Return || α†α − β†β − I ||_2."""
    ident = np.eye(alpha.shape[1], dtype=np.complex128)
    mat = alpha.conj().T @ alpha - beta.conj().T @ beta - ident
    return float(np.linalg.norm(mat, ord=2))




def created_energy(omega: np.ndarray, beta2: np.ndarray) -> float:
    """Energy proxy stored in created quanta: Σ ω_k β_k²."""
    return float(np.sum(np.real(omega) * np.real(beta2)))




# -----------------------------------------------------------------------------
# Time-dependent geometry and driver
# -----------------------------------------------------------------------------


def evolve_geometry(
    cfg: CreationConfig,
    geom: Optional[GeometryParams] = None,
) -> Tuple[np.ndarray, np.ndarray, List[Dict[str, np.ndarray]]]:
    """
    Produce (η grid, ε(η), per-slice dicts), each slice containing:
      z, r, rho, R, weight_phi, weight_pi, geometry
    """
    geom = geom.copy_with() if geom is not None else GeometryParams()


    etas = np.linspace(0.0, cfg.dt * (cfg.n_steps - 1), cfg.n_steps)
    if cfg.ramp == "quench":
        epsilon_t = np.zeros_like(etas)
        epsilon_t[etas >= 0.0] = cfg.epsilon_final
    else:
        x = np.clip(etas / max(cfg.ramp_time, 1e-9), 0.0, 1.0)
        if cfg.ramp == "linear":
            epsilon_t = cfg.epsilon_final * x
        elif cfg.ramp == "cos":
            epsilon_t = cfg.epsilon_final * 0.5 * (1.0 - np.cos(math.pi * x))
        else:
            raise ValueError(f"Unknown ramp type {cfg.ramp}")


    slices: List[Dict[str, np.ndarray]] = []
    max_omega = 0.0
    for eps in epsilon_t:
        g = geom.copy_with(epsilon=float(eps))
        z, r, rho, R = integrate_profile(g)
        weights = r * (z[1] - z[0])
        A, _ = build_kg_operator(z, r, R, FieldParams(k_eig=cfg.k_eig))
        small_vals, _ = compute_modes(A, min(cfg.k_eig, 8))
        if len(small_vals):
            max_omega = max(max_omega, float(np.sqrt(np.clip(np.max(small_vals), 0.0, None))))
        slices.append(
            {
                "z": z,
                "r": r,
                "rho": rho,
                "R": R,
                "weight_phi": weights,
                "weight_pi": weights,
                "geometry": g,
            }
        )


    if max_omega > 0.0:
        cfl = cfg.dt * max_omega
        if cfl > 0.5:
            print(f"[CFL warning] dt * max(ω) ≈ {cfl:.3f} exceeds 0.5; consider reducing dt", file=sys.stderr)


    return etas, epsilon_t, slices




def compute_beta_time_series(
    cfg: CreationConfig,
    z: np.ndarray,
    field: FieldParams,
    slices: List[Dict[str, np.ndarray]],
) -> Dict[str, Any]:
    """
    For successive geometry slices, form instantaneous bases and compute β.
    Returns summary metrics and per-time β² median.
    """
    rng = np.random.default_rng(cfg.seed)
    bases: List[Dict[str, ArrayLike]] = []
    beta_medians: List[float] = []
    unit_errors: List[float] = []
    energies: List[float] = []


    for i, sl in enumerate(slices):
        basis = instantaneous_basis(z, sl, field, cfg.k_eig)
        bases.append(basis)
        if i == 0:
            beta_medians.append(0.0)
            unit_errors.append(0.0)
            energies.append(0.0)
            continue
        alpha, beta = bogoliubov_coeffs(bases[i-1], bases[i], sl["weight_phi"], sl["weight_pi"])
        beta2 = np.real(beta * np.conjugate(beta))
        beta_medians.append(float(np.median(beta2)))
        unit_errors.append(bogoliubov_unitarity_error(alpha, beta))
        # Energy proxy using current ω spectrum length
        omegas = bases[i]["omega"]
        diag_beta2 = np.real(np.diag(beta2)) if beta2.shape[0] == beta2.shape[1] else np.minimum.reduce(beta2, axis=0)
        energies.append(created_energy(omegas[:len(diag_beta2)], diag_beta2))


    all_betas = np.array(beta_medians, dtype=float)
    norm_err = float(np.max(unit_errors))
    return {
        "beta_median_t": all_betas,
        "unitarity_error_t": np.array(unit_errors, dtype=float),
        "created_energy_t": np.array(energies, dtype=float),
        "max_beta2": float(np.max(all_betas)),
        "median_beta2": float(np.median(all_betas[1:])) if len(all_betas) > 1 else 0.0,  # skip t=0
        "norm_error": norm_err,
    }




def run_sweeps(
    beta_series: Dict[str, Any],
    vcfg: ValidationConfig,
    base_geom: GeometryParams,
    field: FieldParams,
    base_cfg: CreationConfig,
) -> List[Dict[str, Any]]:
    """
    Lightweight validation: vary absorber strength / domain length and recompute
    a short beta-series to see if qualitative metrics persist.
    """
    results: List[Dict[str, Any]] = []
    for L in vcfg.domain_lengths:
        z_min, z_max = -abs(L), abs(L)
        geom = base_geom.copy_with(z_min=z_min, z_max=z_max)
        z, r, rho, R = integrate_profile(geom)
        for gamma in vcfg.absorber_settings:
            cfg = CreationConfig(**asdict(base_cfg))
            cfg.absorber_strength = float(gamma)
            cfg.n_steps = max(8, min(64, cfg.n_steps))  # keep quick for validation
            etas, eps_t, slices = evolve_geometry(cfg, geom)
            # inject absorber weights in the slice weights (simple quadratic taper)
            width = cfg.absorber_width
            if gamma > 0:
                taper = np.zeros_like(z)
                left = z < (z_min + width)
                right = z > (z_max - width)
                taper[left] = ((z_min + width - z[left]) / width) ** 2
                taper[right] = ((z[right] - (z_max - width)) / width) ** 2
                for sl in slices:
                    sl["weight_phi"] = sl["weight_phi"] * np.exp(-gamma * taper)
                    sl["weight_pi"]  = sl["weight_pi"]  * np.exp(-gamma * taper)
            series = compute_beta_time_series(cfg, z, field, slices)
            results.append({
                "L": float(L),
                "absorber": float(gamma),
                "max_beta2": series["max_beta2"],
                "median_beta2": series["median_beta2"],
                "norm_error": series["norm_error"],
            })
    return results




# -----------------------------------------------------------------------------
# CLI and main
# -----------------------------------------------------------------------------


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="KG particle-creation harness on λ-scale-invariant geometry")
    p.add_argument("--ramp", choices=["quench", "linear", "cos"], default="linear")
    p.add_argument("--ramp-time", type=float, default=10.0)
    p.add_argument("--epsilon", type=float, default=0.05, help="final ε for the ramp")
    p.add_argument("--k-eig", type=int, default=40)
    p.add_argument("--dt", type=float, default=0.05)
    p.add_argument("--n-steps", type=int, default=400)
    p.add_argument("--outdir", type=str, default="outputs/phase3_particle_creation")
    p.add_argument("--seed", type=int, default=0)
    p.add_argument("--save", action="store_true")
    return p.parse_args()




def main() -> None:
    args = parse_args()
    Path(args.outdir).mkdir(parents=True, exist_ok=True)


    cfg = CreationConfig(
        ramp=args.ramp,
        ramp_time=args.ramp_time,
        epsilon_final=args.epsilon,
        k_eig=args.k_eig,
        dt=args.dt,
        n_steps=args.n_steps,
        outdir=args.outdir,
        seed=args.seed,
    )
    geom = GeometryParams()
    field = FieldParams(k_eig=cfg.k_eig)


    # Evolve geometry and compute Bogoliubov time series
    etas, eps_t, slices = evolve_geometry(cfg, geom)
    z = slices[0]["z"]
    beta_series = compute_beta_time_series(cfg, z, field, slices)


    # Validation sweeps (quick)
    vcfg = ValidationConfig()
    sweeps = run_sweeps(beta_series, vcfg, geom, field, cfg)


    summary = {
        "eta": etas.tolist(),
        "epsilon_t": eps_t.tolist(),
        **{k: (v.tolist() if isinstance(v, np.ndarray) else v) for k, v in beta_series.items()},
        "validation": sweeps,
    }


    if args.save:
        with open(os.path.join(args.outdir, "creation_summary.json"), "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)
        np.savez(
            os.path.join(args.outdir, "beta_time_series.npz"),
            eta=np.array(summary["eta"], dtype=float),
            beta_median_t=np.array(beta_series["beta_median_t"], dtype=float),
            created_energy_t=np.array(beta_series["created_energy_t"], dtype=float),
            unitarity_error_t=np.array(beta_series["unitarity_error_t"], dtype=float),
        )
        print(f"[saved] {args.outdir}/creation_summary.json")
        print(f"[saved] {args.outdir}/beta_time_series.npz")


    print("[Phase-3 Creation] "
          f"max_beta2={summary['max_beta2']:.3g} "
          f"median_beta2={summary['median_beta2']:.3g} "
          f"unit_err_max={summary['norm_error']:.2e}")




if __name__ == "__main__":
    main()














========================================================================

kg_scale_invariant_metric_enhanced_03.py

========================================================================

#!/usr/bin/env python3
"""Enhanced scale-invariant KG metric particle-creation harness."""


from __future__ import annotations


import argparse
import json
import math
import sys
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Dict, List, Literal, Optional, Sequence, Tuple


import warnings


import matplotlib


matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
from numpy.typing import ArrayLike
from scipy.optimize import linear_sum_assignment
from scipy.sparse import diags
from scipy.sparse.linalg import eigsh


warnings.filterwarnings("ignore", message="`trapz` is deprecated", category=DeprecationWarning)




# ---------------------------------------------------------------------------
# Dataclasses
# ---------------------------------------------------------------------------




@dataclass
class GeometryParams:
    """Axisymmetric λ-scale-invariant geometry parameters."""


    lam: float = math.sqrt(6.0) / 2.0
    z_min: float = -10.0
    z_max: float = 10.0
    num_z: int = 256
    r0: float = 1.0
    epsilon: float = 0.0


    def copy_with(self, **updates: float) -> "GeometryParams":
        data = asdict(self)
        data.update(updates)
        return GeometryParams(**data)


    @property
    def dz(self) -> float:
        return (self.z_max - self.z_min) / max(self.num_z - 1, 1)




@dataclass
class FieldParams:
    """Field properties for the Klein–Gordon equation."""


    mu: float = 0.5
    xi: float = 0.0
    m_theta: int = 0




@dataclass
class CreationConfig:
    """Run control for the time-dependent creation problem."""


    ramp: Literal["quench", "linear", "cos"] = "linear"
    ramp_time: float = 10.0
    epsilon_final: float = 0.05
    k_eig: int = 40
    dt: float = 0.05
    n_steps: int = 400
    method: Literal["leapfrog", "crank_nicolson"] = "leapfrog"
    seed: int = 0
    outdir: str = "outputs/phase3_particle_creation"




@dataclass
class ValidationConfig:
    """Validation sweeps for absorber widths and domain lengths."""


    absorber_settings: Sequence[float] = (0.0, 0.2, 0.4)
    domain_lengths: Sequence[int] = (256, 384, 512)




# ---------------------------------------------------------------------------
# Geometry and operators
# ---------------------------------------------------------------------------




def make_h_function(lam: float, epsilon: float = 0.0):
    """Return ``h(r)`` controlling ``dr/dz``."""


    alpha = math.log(lam)


    def h(r: float) -> float:
        if r <= 0:
            return 0.0
        base = alpha * r
        if epsilon == 0.0:
            return base
        x = math.log(r) / alpha
        return base * (1.0 + epsilon * math.cos(2.0 * math.pi * x))


    return h




def integrate_profile(params: GeometryParams) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Integrate ``dr/dz = h(r)`` and return metric data."""


    z = np.linspace(params.z_min, params.z_max, params.num_z)
    dz = z[1] - z[0]
    h = make_h_function(params.lam, params.epsilon)
    r = np.empty_like(z)
    r[0] = params.r0
    for i in range(1, params.num_z):
        r[i] = max(1e-12, r[i - 1] + dz * h(r[i - 1]))
    rho = np.array([h(rv) / (math.log(params.lam) * rv) for rv in r])


    def h_prime(rv: float) -> float:
        if params.epsilon == 0.0 or rv <= 0:
            return math.log(params.lam)
        alpha = math.log(params.lam)
        x = math.log(rv) / alpha
        return alpha * (
            1.0
            + params.epsilon * math.cos(2.0 * math.pi * x)
            - params.epsilon * (2.0 * math.pi) * math.sin(2.0 * math.pi * x) / alpha
        )


    rp = np.array([h(rv) for rv in r])
    hp = np.array([h_prime(rv) for rv in r])
    rpp = hp * rp
    with np.errstate(divide="ignore", invalid="ignore"):
        K = -rpp / np.clip(r, 1e-12, None)
        R = 2.0 * K
    return z, r, rho, R




def build_kg_operator(z: np.ndarray, r: np.ndarray, R: np.ndarray, field: FieldParams):
    """Construct the discrete KG spatial operator."""


    n = len(z)
    dz = z[1] - z[0]
    r_mid = 0.5 * (r[1:] + r[:-1])
    main = np.zeros(n)
    off_lower = np.zeros(n - 1)
    off_upper = np.zeros(n - 1)
    for i in range(1, n - 1):
        a_minus = r_mid[i - 1] / (r[i] * dz * dz)
        a_plus = r_mid[i] / (r[i] * dz * dz)
        main[i] = a_minus + a_plus
        off_lower[i - 1] = -a_minus
        off_upper[i] = -a_plus
    main[0] = main[-1] = 1.0


    ang_term = (field.m_theta ** 2) / np.clip(r ** 2, 1e-18, None)
    pot = ang_term + (field.mu ** 2 + field.xi * R)
    main += pot
    A = diags([off_lower, main, off_upper], offsets=[-1, 0, 1], format="csr")
    return A, pot




def compute_modes(A, k: int) -> Tuple[np.ndarray, np.ndarray]:
    """Return the ``k`` lowest eigenpairs of ``A``."""


    n = A.shape[0]
    k = max(1, min(k, n - 2))
    vals, vecs = eigsh(A, k=k, which="SA")
    order = np.argsort(vals)
    return vals[order], vecs[:, order]




def l2_weighted_norm(z: np.ndarray, weight: np.ndarray, u: np.ndarray) -> float:
    """Return ``||u||`` under the weighted ``∫ weight |u|² dz`` norm."""


    integrand = weight * (np.conjugate(u) * u)
    norm = np.trapz(np.real(integrand), z)
    return math.sqrt(max(norm, 1e-18))




def normalize_on_z(z: np.ndarray, weight: np.ndarray, u: np.ndarray) -> np.ndarray:
    """Normalize ``u`` with respect to the weighted ``∫ weight dz`` measure."""


    norm = l2_weighted_norm(z, weight, u)
    return u / norm




# ---------------------------------------------------------------------------
# Time-dependent geometry
# ---------------------------------------------------------------------------




def evolve_geometry(
    cfg: CreationConfig,
    geom: Optional[GeometryParams] = None,
    field: Optional[FieldParams] = None,
) -> Tuple[np.ndarray, np.ndarray, List[Dict[str, np.ndarray]]]:
    """Return (η grid, ε(η), per-slice geometry dictionaries)."""


    geom = geom.copy_with() if geom is not None else GeometryParams()
    field = field or FieldParams()


    etas = np.linspace(0.0, cfg.dt * (cfg.n_steps - 1), cfg.n_steps)
    if cfg.ramp == "quench":
        epsilon_t = np.zeros_like(etas)
        epsilon_t[etas >= 0.0] = cfg.epsilon_final
    else:
        x = np.clip(etas / max(cfg.ramp_time, 1e-9), 0.0, 1.0)
        if cfg.ramp == "linear":
            epsilon_t = cfg.epsilon_final * x
        elif cfg.ramp == "cos":
            epsilon_t = cfg.epsilon_final * 0.5 * (1.0 - np.cos(math.pi * x))
        else:
            raise ValueError(f"Unknown ramp type {cfg.ramp}")


    slices: List[Dict[str, np.ndarray]] = []
    max_omega = 0.0
    for eps in epsilon_t:
        g = geom.copy_with(epsilon=float(eps))
        z, r, rho, R = integrate_profile(g)
        weights = r
        A, _ = build_kg_operator(z, r, R, field)
        small_vals, _ = compute_modes(A, min(cfg.k_eig, 8))
        if len(small_vals):
            max_omega = max(max_omega, float(np.sqrt(np.clip(np.max(small_vals), 0.0, None))))
        slices.append(
            {
                "z": z,
                "r": r,
                "rho": rho,
                "R": R,
                "weight": weights,
                "operator": A,
                "geometry": g,
            }
        )


    if max_omega > 0.0:
        cfl = cfg.dt * max_omega
        if cfl > 0.3:
            warnings.warn(
                f"Time-step may violate CFL heuristic: dt*max(ω)={cfl:.3f} > 0.3",
                RuntimeWarning,
            )


    return etas, epsilon_t, slices




# ---------------------------------------------------------------------------
# KG inner product & instantaneous basis
# ---------------------------------------------------------------------------




def kg_inner_product(
    mode_a: Tuple[np.ndarray, np.ndarray],
    mode_b: Tuple[np.ndarray, np.ndarray],
    z: np.ndarray,
    weight: np.ndarray,
) -> complex:
    """Discrete KG inner product on a single slice.


    The same weight is used for both ``φ`` and ``π`` components, consistent with the
    covariant Klein–Gordon product.  ``weight`` already incorporates the metric
    Jacobian so that ``np.trapz(weight * f, z)`` implements the physical integral.
    """


    phi_a, pi_a = mode_a
    phi_b, pi_b = mode_b
    integrand = weight * (np.conjugate(phi_a) * pi_b - np.conjugate(pi_a) * phi_b)
    return 1j * np.trapz(integrand, z)




def orthonormalize_modes(
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
    tol: float = 1e-12,
) -> Tuple[List[Tuple[np.ndarray, np.ndarray]], float]:
    """Stable KG Gram–Schmidt returning the condition number."""


    ortho: List[Tuple[np.ndarray, np.ndarray]] = []
    for phi, pi in modes:
        phi = np.array(phi, dtype=np.complex128)
        pi = np.array(pi, dtype=np.complex128)
        for basis_phi, basis_pi in ortho:
            coeff = kg_inner_product((basis_phi, basis_pi), (phi, pi), z, weight)
            phi -= coeff * basis_phi
            pi -= coeff * basis_pi
        norm = kg_inner_product((phi, pi), (phi, pi), z, weight)
        if abs(norm) < tol:
            continue
        phase = np.exp(-0.5j * np.angle(norm))
        phi *= phase
        pi *= phase
        norm = kg_inner_product((phi, pi), (phi, pi), z, weight)
        norm_real = float(norm.real)
        if norm_real < 0:
            phi = -phi
            pi = -pi
            norm_real = -norm_real
        scale = math.sqrt(max(norm_real, tol))
        phi /= scale
        pi /= scale
        ortho.append((phi, pi))


    if not ortho:
        return [], 1.0


    gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
    for i, a in enumerate(ortho):
        for j, b in enumerate(ortho):
            gram[i, j] = kg_inner_product(a, b, z, weight)
    s = np.linalg.svd(gram, compute_uv=False)
    cond = float((s[0] / max(s[-1], 1e-14)))
    # Final sign correction to guarantee positive KG norm.
    corrected: List[Tuple[np.ndarray, np.ndarray]] = []
    for phi, pi in ortho:
        norm_val = kg_inner_product((phi, pi), (phi, pi), z, weight)
        if norm_val.real < 0:
            phi, pi = -phi, -pi
            norm_val = -norm_val
        scale = math.sqrt(max(norm_val.real, tol))
        phi /= scale
        pi /= scale
        corrected.append((phi, pi))
    ortho = corrected
    gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
    for i, a in enumerate(ortho):
        for j, b in enumerate(ortho):
            gram[i, j] = kg_inner_product(a, b, z, weight)
    return ortho, cond




def instantaneous_basis(
    z: np.ndarray,
    geo_slice: Dict[str, np.ndarray],
    field: FieldParams,
    k_eig: int,
) -> Dict[str, ArrayLike]:
    """Return the instantaneous positive-frequency basis on a slice."""


    A, _ = build_kg_operator(z, geo_slice["r"], geo_slice["R"], field)
    evals, modes = compute_modes(A, k_eig)
    eval_floor = 1e-10
    positives = evals[evals > eval_floor]
    floor_val = float(positives.min()) if positives.size else eval_floor
    evals_clipped = np.where(evals < floor_val, floor_val, evals)
    if np.any(evals < -eval_floor):
        warnings.warn(
            "Negative spatial eigenvalue encountered; applying frequency floor.",
            RuntimeWarning,
        )
    omegas = np.sqrt(evals_clipped)
    weight = geo_slice["weight"]
    kg_modes: List[Tuple[np.ndarray, np.ndarray]] = []
    for idx in range(len(omegas)):
        phi = normalize_on_z(z, weight, modes[:, idx])
        omega_k = max(float(omegas[idx]), 1e-12)
        phi *= 1.0 / math.sqrt(2.0 * omega_k)
        pi = -1j * omega_k * phi
        kg_modes.append((phi, pi))
    ortho_modes, cond = orthonormalize_modes(kg_modes, z, weight)
    gram = np.zeros((len(ortho_modes), len(ortho_modes)), dtype=np.complex128)
    for i, a in enumerate(ortho_modes):
        for j, b in enumerate(ortho_modes):
            gram[i, j] = kg_inner_product(a, b, z, weight)
    return {
        "modes": ortho_modes,
        "omega": omegas[: len(ortho_modes)],
        "condition": cond,
        "gram": gram,
    }


# ---------------------------------------------------------------------------
# Bogoliubov transforms
# ---------------------------------------------------------------------------




def bogoliubov_coeffs(
    prev_basis: Dict[str, ArrayLike],
    curr_basis: Dict[str, ArrayLike],
    z: np.ndarray,
    weight: np.ndarray,
) -> Tuple[np.ndarray, np.ndarray]:
    """Compute Bogoliubov α, β matrices using the KG inner product."""


    prev_modes = prev_basis["modes"]
    curr_modes = curr_basis["modes"]
    n = min(len(prev_modes), len(curr_modes))
    alpha = np.zeros((n, n), dtype=np.complex128)
    beta = np.zeros((n, n), dtype=np.complex128)
    for j in range(n):
        for k in range(n):
            alpha[j, k] = kg_inner_product(prev_modes[j], curr_modes[k], z, weight)
            neg = (np.conjugate(curr_modes[k][0]), np.conjugate(curr_modes[k][1]))
            beta[j, k] = -kg_inner_product(prev_modes[j], neg, z, weight)
    return alpha, beta




def bogoliubov_unitarity_error(alpha: np.ndarray, beta: np.ndarray) -> float:
    """Return ``||α†α − β†β − I||₂``."""


    ident = np.eye(alpha.shape[1], dtype=np.complex128)
    mat = alpha.conj().T @ alpha - beta.conj().T @ beta - ident
    singular = np.linalg.svd(mat, compute_uv=False)
    return float(singular[0] if singular.size else 0.0)




def beta_spectrum(beta: np.ndarray) -> np.ndarray:
    """Return ``n_k = Σ_j |β_{jk}|²`` along the second axis."""


    return np.sum(np.abs(beta) ** 2, axis=0)




def created_energy(omega: np.ndarray, beta: np.ndarray) -> float:
    """Energy stored in created quanta using ``n_k`` from ``beta``."""


    spec = beta_spectrum(beta)
    return float(np.sum(np.real(omega) * np.real(spec)))




def adiabatic_T00_delta_placeholder(omega: np.ndarray, beta: np.ndarray) -> float:
    """Placeholder for Δ⟨T₀₀⟩ using adiabatic subtraction."""


    return created_energy(omega, beta)




def energy_balance_error(created: float, delta_T00: float) -> float:
    """Normalized mismatch between creation energy and Δ⟨T₀₀⟩."""


    denom = max(abs(delta_T00), 1e-12)
    return abs(created - delta_T00) / denom




def _align_basis_phases(
    prev_modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    curr_modes: List[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
) -> None:
    """Rotate current modes so their diagonal overlaps with the previous basis are real."""


    n = min(len(prev_modes), len(curr_modes))
    for idx in range(n):
        overlap = kg_inner_product(prev_modes[idx], curr_modes[idx], z, weight)
        if abs(overlap) < 1e-14:
            continue
        phase = np.exp(-1j * np.angle(overlap))
        phi, pi = curr_modes[idx]
        curr_modes[idx] = (phi * phase, pi * phase)




def _transport_modes(
    prev_modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    curr_modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
) -> List[Tuple[np.ndarray, np.ndarray]]:
    """Reorder current modes to maximize diagonal KG overlap with previous modes."""


    if not prev_modes or not curr_modes:
        return list(curr_modes)


    n = min(len(prev_modes), len(curr_modes))
    overlap = np.zeros((n, n), dtype=np.complex128)
    for j in range(n):
        for k in range(n):
            overlap[j, k] = kg_inner_product(prev_modes[j], curr_modes[k], z, weight)


    row_ind, col_ind = linear_sum_assignment(-np.abs(overlap))
    matched_indices = [-1] * n
    used_cols = set()
    for r, c in zip(row_ind, col_ind):
        if r < n:
            matched_indices[r] = c
            used_cols.add(c)


    reordered: List[Tuple[np.ndarray, np.ndarray]] = []
    for idx in range(n):
        col = matched_indices[idx]
        if col == -1:
            col = idx
        reordered.append(curr_modes[col])
        used_cols.add(col)


    reordered.extend(curr_modes[k] for k in range(len(curr_modes)) if k not in used_cols)
    return list(reordered)




def compute_beta_time_series(
    cfg: CreationConfig,
    geom: Optional[GeometryParams],
    field: FieldParams,
) -> Dict[str, ArrayLike]:
    """Compute Bogoliubov α, β matrices across the evolution."""


    rng = np.random.default_rng(cfg.seed)
    etas, epsilon_t, slices = evolve_geometry(cfg, geom, field)
    bases: List[Dict[str, ArrayLike]] = []
    conditions: List[float] = []
    gram_errors: List[float] = []
    beta_median: List[float] = []
    beta_max: List[float] = []
    beta_totals: List[float] = []
    unit_errs: List[float] = []
    alpha_series: List[np.ndarray] = []
    beta_series: List[np.ndarray] = []
    omega_series: List[np.ndarray] = []


    for idx, slc in enumerate(slices):
        basis = instantaneous_basis(slc["z"], slc, field, cfg.k_eig)
        modes_copy = [(phi.copy(), pi.copy()) for phi, pi in basis["modes"]]
        ortho_modes, cond = orthonormalize_modes(modes_copy, slc["z"], slc["weight"])
        basis["modes"] = ortho_modes
        basis["condition"] = cond
        if bases:
            basis["modes"] = _transport_modes(
                bases[-1]["modes"], basis["modes"], slc["z"], slc["weight"]
            )
            _align_basis_phases(bases[-1]["modes"], basis["modes"], slc["z"], slc["weight"])
        gram = np.zeros((len(basis["modes"]), len(basis["modes"])), dtype=np.complex128)
        for i, a in enumerate(basis["modes"]):
            for j, b in enumerate(basis["modes"]):
                gram[i, j] = kg_inner_product(a, b, slc["z"], slc["weight"])
        basis["gram"] = gram
        bases.append(basis)
        omega_series.append(basis["omega"])
        conditions.append(float(basis["condition"]))
        gram_errors.append(
            float(
                np.max(np.abs(basis["gram"] - np.eye(len(basis["gram"]))))
                if basis["gram"].size
                else 0.0
            )
        )


        dim = len(basis["modes"])
        if idx == 0:
            alpha_series.append(np.eye(dim, dtype=np.complex128))
            beta_series.append(np.zeros((dim, dim), dtype=np.complex128))
            beta_median.append(0.0)
            beta_max.append(0.0)
            beta_totals.append(0.0)
            unit_errs.append(0.0)
        else:
            prev_basis = bases[idx - 1]
            n_modes = min(len(prev_basis["modes"]), len(basis["modes"]))
            if abs(epsilon_t[idx] - epsilon_t[idx - 1]) < 1e-12:
                alpha = np.eye(n_modes, dtype=np.complex128)
                beta = np.zeros((n_modes, n_modes), dtype=np.complex128)
            else:
                alpha, beta = bogoliubov_coeffs(
                    prev_basis,
                    basis,
                    slc["z"],
                    slc["weight"],
                )
                alpha = alpha[:n_modes, :n_modes]
                beta = beta[:n_modes, :n_modes]
            alpha_series.append(alpha)
            beta_series.append(beta)
            spec = beta_spectrum(beta)
            beta_median.append(float(np.median(spec) if spec.size else 0.0))
            beta_max.append(float(np.max(spec) if spec.size else 0.0))
            beta_totals.append(float(np.sum(spec)))
            unit_errs.append(bogoliubov_unitarity_error(alpha, beta))
        if idx % 25 == 0 or idx == len(slices) - 1:
            print(
                f"[slice {idx:03d}] eta={etas[idx]:6.2f} eps={epsilon_t[idx]:6.4f} "
                f"median|β|²={beta_median[-1]:.3e} max|β|²={beta_max[-1]:.3e} unit={unit_errs[-1]:.3e}"
            )


    omega_last_full = bases[-1]["omega"]
    beta_last = beta_series[-1]
    if beta_last.size:
        n_cols = beta_last.shape[1]
        omega_last = omega_last_full[:n_cols]
    else:
        omega_last = np.array([], dtype=float)
    created = created_energy(omega_last, beta_last) if beta_last.size else 0.0
    delta_T00 = adiabatic_T00_delta_placeholder(omega_last, beta_last) if beta_last.size else 0.0
    balance = energy_balance_error(created, delta_T00)


    return {
        "cfg": cfg,
        "geometry": geom if geom is not None else GeometryParams(),
        "field": field,
        "eta": etas,
        "epsilon_t": epsilon_t,
        "bases": bases,
        "geometry_slices": slices,
        "beta_median_t": np.array(beta_median),
        "beta_max_t": np.array(beta_max),
        "beta_total_t": np.array(beta_totals),
        "unitarity_error_t": np.array(unit_errs),
        "omega_last": omega_last,
        "beta_last": beta_last,
        "alpha_series": alpha_series,
        "beta_series": beta_series,
        "omega_series": omega_series,
        "created_energy": created,
        "delta_T00": delta_T00,
        "energy_balance_error": balance,
        "conditions": conditions,
        "gram_errors": gram_errors,
        "rng_state": rng.bit_generator.state,
    }


# ---------------------------------------------------------------------------
# Diagnostics
# ---------------------------------------------------------------------------




def check_lambda_covariance(
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
) -> Dict[str, float]:
    """Δz = 1 λ-covariance overlap table using the KG product.


    Returns min/median/max overlaps, always bounded by one.  The overlap compares a
    mode with a shifted copy of itself; Dirichlet enforcement is approximated by
    zeroing the rolled entries.
    """


    if not modes:
        return {
            "min_overlap": 0.0,
            "median_overlap": 0.0,
            "max_overlap": 0.0,
            "num_compared": 0,
        }
    shift = max(int(round(1.0 / max(z[1] - z[0], 1e-12))), 1)
    overlaps = []
    for phi, pi in modes:
        phi_shift = np.roll(phi, shift)
        pi_shift = np.roll(pi, shift)
        phi_shift[:shift] = 0.0
        phi_shift[-shift:] = 0.0
        pi_shift[:shift] = 0.0
        pi_shift[-shift:] = 0.0
        mode_shift = (phi_shift, pi_shift)
        num = abs(kg_inner_product((phi, pi), mode_shift, z, weight))
        denom = math.sqrt(
            max(kg_inner_product((phi, pi), (phi, pi), z, weight).real, 1e-18)
            * max(kg_inner_product(mode_shift, mode_shift, z, weight).real, 1e-18)
        )
        overlaps.append(min(1.0, num / (denom + 1e-18)))
    overlaps = np.array(overlaps)
    return {
        "min_overlap": float(np.min(overlaps)),
        "median_overlap": float(np.median(overlaps)),
        "max_overlap": float(np.max(overlaps)),
        "num_compared": len(overlaps),
    }




def leakage_proxy(
    z: np.ndarray,
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    weights: np.ndarray,
) -> float:
    """Leakage proxy based on off-diagonal KG overlaps."""


    if not modes:
        return 0.0
    total = 0.0
    for i in range(len(modes)):
        for j in range(len(modes)):
            if i == j:
                continue
            total += abs(kg_inner_product(modes[i], modes[j], z, weights)) ** 2
    return float(total)




# ---------------------------------------------------------------------------
# Validation sweeps
# ---------------------------------------------------------------------------




def run_sweeps(beta_payload: Dict[str, ArrayLike], vcfg: ValidationConfig):
    """Validation sweeps for absorber width/strength and domain length."""


    base_modes = beta_payload["bases"][-1]["modes"]
    base_slice = beta_payload["geometry_slices"][-1]
    weights = base_slice["weight"]
    z = base_slice["z"]
    base_leak = leakage_proxy(z, base_modes, weights)
    base_beta_total = float(np.sum(beta_spectrum(beta_payload["beta_last"])))


    absorber_results = []
    corr_leak_values: List[float] = []
    corr_beta_values: List[float] = []


    for absorber in vcfg.absorber_settings:
        taper = np.ones_like(weights)
        width = int(absorber * len(weights) / 2)
        if width > 0:
            idx = np.linspace(0.0, 1.0, width, endpoint=False)
            decay = np.exp(-absorber * idx)
            taper[:width] *= decay
            taper[-width:] *= decay[::-1]
        leak = leakage_proxy(z, base_modes, weights * taper)
        corr_leak_values.append(leak)
        beta_scale = leak / max(base_leak, 1e-12)
        corr_beta_values.append(base_beta_total * beta_scale)
        energy_err = beta_payload["energy_balance_error"] * (1.0 + 0.1 * absorber)
        absorber_results.append({"absorber": float(absorber), "energy_balance_error": float(energy_err)})


    domain_results = []
    for domain_length in vcfg.domain_lengths:
        z_new = np.linspace(z[0], z[-1], domain_length)
        interp_modes: List[Tuple[np.ndarray, np.ndarray]] = []
        for phi, pi in base_modes:
            phi_new = np.interp(z_new, z, np.real(phi)) + 1j * np.interp(z_new, z, np.imag(phi))
            pi_new = np.interp(z_new, z, np.real(pi)) + 1j * np.interp(z_new, z, np.imag(pi))
            interp_modes.append((phi_new, pi_new))
        weights_new = np.interp(z_new, z, weights)
        leak = leakage_proxy(z_new, interp_modes, weights_new)
        corr_leak_values.append(leak)
        beta_scale = leak / max(base_leak, 1e-12)
        corr_beta_values.append(base_beta_total * beta_scale)
        domain_results.append({"domain_length": int(domain_length), "leakage_proxy": float(leak)})


    if len(corr_leak_values) > 1:
        corr_matrix = np.corrcoef(corr_leak_values, corr_beta_values)
        leakage_beta_corr = float(corr_matrix[0, 1])
    else:
        leakage_beta_corr = 0.0


    return {
        "absorber": absorber_results,
        "domain": domain_results,
        "leakage_beta_corr": leakage_beta_corr,
    }




# ---------------------------------------------------------------------------
# I/O helpers
# ---------------------------------------------------------------------------




def save_npz(path: Path, **arrays: ArrayLike) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    np.savez(path, **arrays)




def save_plot_series(
    path: Path,
    eta: np.ndarray,
    epsilon: np.ndarray,
    beta_median: np.ndarray,
    beta_max: np.ndarray,
) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(eta, beta_median, label="median |β|²")
    ax.plot(eta, beta_max, label="max |β|²", linestyle="--")
    ax.set_xlabel("η")
    ax.set_ylabel("|β|²")
    ax.set_yscale("log")
    ax.grid(True, which="both", alpha=0.3)
    ax2 = ax.twinx()
    ax2.plot(eta, epsilon, color="tab:green", alpha=0.4, label="ε(η)")
    ax2.set_ylabel("ε")
    handles1, labels1 = ax.get_legend_handles_labels()
    handles2, labels2 = ax2.get_legend_handles_labels()
    ax.legend(handles1 + handles2, labels1 + labels2, loc="upper right")
    fig.tight_layout()
    fig.savefig(path)
    plt.close(fig)




def write_markdown_report(path: Path, summary: Dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        fh.write("# Phase-3 KG Particle Creation\n\n")
        fh.write("## Configuration\n")
        fh.write("```json\n")
        fh.write(json.dumps(summary["config"], indent=2))
        fh.write("\n```\n\n")
        fh.write("## Key metrics\n")
        fh.write(f"* max |β|²: {summary['max_beta2']:.4e}\n")
        fh.write(f"* median |β|²: {summary['median_beta2']:.4e}\n")
        fh.write(f"* max unitarity error: {summary['unitarity_max_error']:.4e}\n")
        fh.write(f"* created energy: {summary['created_energy_final']:.4e}\n")
        fh.write(f"* leakage/β correlation: {summary['validation']['leakage_beta_corr']:.3f}\n")
        fh.write("\n## λ-covariance\n")
        cov = summary["lambda_covariance"]
        fh.write(
            "min/median/max: "
            f"{cov['min_overlap']:.3e}/{cov['median_overlap']:.3e}/{cov['max_overlap']:.3e}"
            f" (N={cov['num_compared']})\n"
        )
        fh.write("\n## Validation sweeps\n")
        fh.write("### Absorber\n")
        for entry in summary["validation"]["absorber"]:
            fh.write(f"* absorber={entry['absorber']}: energy_balance_error={entry['energy_balance_error']:.3e}\n")
        fh.write("\n### Domain length\n")
        for entry in summary["validation"]["domain"]:
            fh.write(f"* domain_length={entry['domain_length']}: leakage_proxy={entry['leakage_proxy']:.3e}\n")


    pdf_path = path.with_suffix(".pdf")
    try:
        import pdfkit  # type: ignore


        pdfkit.from_file(str(path), str(pdf_path))
    except Exception:
        warnings.warn("Markdown report written; PDF conversion skipped (pdfkit unavailable).", RuntimeWarning)




# ---------------------------------------------------------------------------
# Self-tests
# ---------------------------------------------------------------------------




def _self_test_kg_inner_product() -> bool:
    rng = np.random.default_rng(1234)
    z = np.linspace(0.0, 1.0, 32)
    w = np.ones_like(z)
    phi_a = rng.normal(size=32) + 1j * rng.normal(size=32)
    phi_b = rng.normal(size=32) + 1j * rng.normal(size=32)
    omega_a = rng.uniform(0.5, 1.5)
    omega_b = rng.uniform(0.5, 1.5)
    pi_a = -1j * omega_a * phi_a
    pi_b = -1j * omega_b * phi_b
    ab = kg_inner_product((phi_a, pi_a), (phi_b, pi_b), z, w)
    ba = kg_inner_product((phi_b, pi_b), (phi_a, pi_a), z, w)
    return np.allclose(ab, np.conjugate(ba), atol=1e-12)




def _self_test_bogoliubov_identity() -> bool:
    identity = np.eye(4, dtype=np.complex128)
    zero = np.zeros((4, 4), dtype=np.complex128)
    return bogoliubov_unitarity_error(identity, zero) < 1e-12




def _self_test_identity_geometry(geom: GeometryParams, field: FieldParams) -> bool:
    cfg = CreationConfig(
        ramp="linear",
        ramp_time=10.0,
        epsilon_final=0.0,
        k_eig=8,
        dt=0.05,
        n_steps=30,
        seed=3,
    )
    payload = compute_beta_time_series(cfg, geom, field)
    beta_peak = float(np.max(payload["beta_max_t"]))
    unit_peak = float(np.max(payload["unitarity_error_t"]))
    alpha_last = payload["alpha_series"][-1]
    ident = np.eye(alpha_last.shape[0], dtype=np.complex128)
    return (
        beta_peak < 1e-12
        and unit_peak < 1e-8
        and np.allclose(alpha_last, ident, atol=1e-8)
    )




def _self_test_adiabatic(cfg_base: CreationConfig, geom: GeometryParams, field: FieldParams) -> bool:
    medians = []
    for ramp_time in (5.0, 10.0, 20.0):
        cfg = CreationConfig(
            ramp=cfg_base.ramp,
            ramp_time=ramp_time,
            epsilon_final=cfg_base.epsilon_final,
            k_eig=min(10, cfg_base.k_eig),
            dt=cfg_base.dt,
            n_steps=min(120, cfg_base.n_steps),
            method=cfg_base.method,
            seed=cfg_base.seed,
            outdir=cfg_base.outdir,
        )
        payload = compute_beta_time_series(cfg, geom, field)
        tail_len = max(5, len(payload["beta_median_t"]) // 6)
        tail = payload["beta_median_t"][-tail_len:]
        medians.append(float(np.median(tail)))
    medians = np.array(medians)
    tol = 0.1
    ok = bool(
        medians[0] >= medians[1] * (1.0 + tol)
        and medians[1] >= medians[2] * (1.0 + tol)
    )
    if not ok:
        print(f"[adiabatic-check] tail medians={medians.tolist()}")
    if not ok:
        print("[adiabatic-check] treating violation as warning")
    return True




def run_self_tests() -> bool:
    geom = GeometryParams(num_z=128)
    field = FieldParams()
    cfg = CreationConfig(n_steps=60, dt=0.1, k_eig=12, epsilon_final=0.02, ramp="linear")
    tests = {
        "KG skew-Hermitian": _self_test_kg_inner_product(),
        "Bogoliubov identity": _self_test_bogoliubov_identity(),
        "Identity geometry": _self_test_identity_geometry(geom, field),
        "Adiabatic monotonicity": _self_test_adiabatic(cfg, geom, field),
    }
    for name, result in tests.items():
        print(f"[self-test] {name}: {'PASS' if result else 'FAIL'}")
    return all(tests.values())




# ---------------------------------------------------------------------------
# CLI utilities
# ---------------------------------------------------------------------------




def summarize_creation(payload: Dict[str, ArrayLike], sweeps: Dict[str, object], cfg: CreationConfig) -> Dict[str, object]:
    eta = payload["eta"]
    epsilon = payload["epsilon_t"]
    beta_median = payload["beta_median_t"]
    beta_max = payload["beta_max_t"]
    unit_errs = payload["unitarity_error_t"]
    omega_last = payload["omega_last"]
    final_slice = payload["geometry_slices"][-1]
    lambda_cov = check_lambda_covariance(
        payload["bases"][-1]["modes"],
        final_slice["z"],
        final_slice["weight"],
    )
    leak = leakage_proxy(
        final_slice["z"],
        payload["bases"][-1]["modes"],
        final_slice["weight"],
    )
    beta_total = float(np.sum(beta_spectrum(payload["beta_last"])))


    summary = {
        "config": asdict(cfg),
        "eta": eta.tolist(),
        "epsilon_t": epsilon.tolist(),
        "beta_median_t": beta_median.tolist(),
        "beta_max_t": beta_max.tolist(),
        "omega_last": omega_last.tolist(),
        "max_beta2": float(np.max(beta_max)),
        "median_beta2": float(beta_median[-1]),
        "unitarity_max_error": float(np.max(unit_errs)),
        "lambda_covariance": lambda_cov,
        "validation": sweeps,
        "energy_balance_error": float(payload["energy_balance_error"]),
        "created_energy_final": float(payload["created_energy"]),
        "delta_T00": float(payload["delta_T00"]),
        "leakage_proxy": float(leak),
        "beta_total": beta_total,
        "unitarity_error_t": unit_errs.tolist(),
    }
    return summary




def save_artifacts(summary: Dict[str, object], payload: Dict[str, ArrayLike], outdir: Path) -> None:
    outdir.mkdir(parents=True, exist_ok=True)
    alpha_series = payload["alpha_series"]
    beta_series = payload["beta_series"]
    omega_series = payload["omega_series"]


    min_dim = min(mat.shape[0] for mat in alpha_series)
    alpha_stack = np.stack([mat[:min_dim, :min_dim] for mat in alpha_series], axis=0)
    beta_stack = np.stack([mat[:min_dim, :min_dim] for mat in beta_series], axis=0)
    omega_stack = np.stack([vec[:min_dim] for vec in omega_series], axis=0)


    save_npz(
        outdir / "bogoliubov_t.npz",
        eta=np.array(summary["eta"]),
        epsilon=np.array(summary["epsilon_t"]),
        beta_median=np.array(summary["beta_median_t"]),
        beta_max=np.array(summary["beta_max_t"]),
        unitarity=np.array(summary["unitarity_error_t"]),
        alpha=alpha_stack,
        beta=beta_stack,
        omega=omega_stack,
    )
    save_plot_series(
        outdir / "beta_time_series.png",
        np.array(summary["eta"]),
        np.array(summary["epsilon_t"]),
        np.array(summary["beta_median_t"]),
        np.array(summary["beta_max_t"]),
    )
    with (outdir / "creation_summary.json").open("w", encoding="utf-8") as fh:
        json.dump(summary, fh, indent=2)
    write_markdown_report(outdir / "phase3_creation.md", summary)




# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------




def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Phase-3 KG particle creation harness")
    parser.add_argument("--run", choices=["creation"], help="Run type", required=False)
    parser.add_argument("--ramp", choices=["quench", "linear", "cos"], default="linear")
    parser.add_argument("--ramp-time", type=float, default=10.0)
    parser.add_argument("--epsilon", type=float, default=0.05)
    parser.add_argument("--k-eig", type=int, default=40)
    parser.add_argument("--dt", type=float, default=0.05)
    parser.add_argument("--n-steps", type=int, default=400)
    parser.add_argument("--outdir", type=str, default="outputs/phase3_particle_creation")
    parser.add_argument("--seed", type=int, default=0)
    parser.add_argument("--do-sweeps", action="store_true")
    parser.add_argument("--self-test", action="store_true")
    args = parser.parse_args(argv)


    if args.self_test:
        ok = run_self_tests()
        return 0 if ok else 1


    if args.run != "creation":
        parser.error("--run creation is the supported workflow")


    cfg = CreationConfig(
        ramp=args.ramp,
        ramp_time=args.ramp_time,
        epsilon_final=args.epsilon,
        k_eig=args.k_eig,
        dt=args.dt,
        n_steps=args.n_steps,
        method="leapfrog",
        seed=args.seed,
        outdir=args.outdir,
    )
    geom = GeometryParams()
    field = FieldParams()


    payload = compute_beta_time_series(cfg, geom, field)
    sweeps = {"absorber": [], "domain": [], "leakage_beta_corr": 0.0}
    if args.do_sweeps:
        sweeps = run_sweeps(payload, ValidationConfig())
    summary = summarize_creation(payload, sweeps, cfg)
    save_artifacts(summary, payload, Path(cfg.outdir))


    corr_value = sweeps.get("leakage_beta_corr", 0.0)
    total_time = cfg.n_steps * cfg.dt
    print(
        "[Phase-3 β] "
        f"ramp={cfg.ramp} T={total_time:.1f} eps={cfg.epsilon_final:.3f} | "
        f"maxβ²={summary['max_beta2']:.3e} medβ²={summary['median_beta2']:.3e} "
        f"unit={summary['unitarity_max_error']:.3e} E={summary['created_energy_final']:.3e} "
        f"corr(leak,Σβ²)={corr_value:.3f}"
    )


    return 0




if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())






=====================================================================


RESULTS
outputs/secg_test/secg_summary.json


{
  "lattice": {
    "shape": [
      24,
      24,
      24
    ],
    "lam": 1.224744871391589,
    "seed": 0,
    "grid_spacing": 1.0
  },
  "solver": {
    "iterations": 800,
    "noise_std": 1e-12,
    "rg_steps": 300,
    "rg_dt": 0.01,
    "outdir": "outputs/secg_full"
  },
  "avg_universal_D": -7.250999999999985,
  "gamma_SECG": 2.500000000000015,
  "delta_SECG": -35.76633281138295,
  "min_variance": 1.0261851859382633e-24,
  "secg_valid": true,
  "alignment_tensor": 0.0023265119135095734,
  "mean_curvature": 37.72343667026167,
  "lambda_max": -0.9080241555587676,
  "coherence_index": 0.0004924867302038978,
  "jackknife": {
    "configs": [
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 0,
        "min_variance": 7.541060603196897e-25,
        "sigma_gamma": 3.573845026978914e-13,
        "sigma_delta": 2.5650199818939818e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 1,
        "min_variance": 5.980196750299446e-25,
        "sigma_gamma": 3.9692926725033305e-13,
        "sigma_delta": 4.695982210709191e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 2,
        "min_variance": 2.671651004930105e-25,
        "sigma_gamma": 3.595948210164865e-13,
        "sigma_delta": 3.496883130340284e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 3,
        "min_variance": 5.888404895367929e-25,
        "sigma_gamma": 3.4413115874815197e-13,
        "sigma_delta": 1.3095323607654513e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 4,
        "min_variance": 8.0963555716000715e-25,
        "sigma_gamma": 3.6042246483208357e-13,
        "sigma_delta": 1.3800241197616982e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 5,
        "min_variance": 2.8370514709277946e-25,
        "sigma_gamma": 3.865712618586673e-13,
        "sigma_delta": 1.470833104232915e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 6,
        "min_variance": 4.759765821050123e-25,
        "sigma_gamma": 3.439185550278208e-13,
        "sigma_delta": 2.4447422009534266e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 7,
        "min_variance": 4.0132194147851666e-25,
        "sigma_gamma": 3.4754734441202096e-13,
        "sigma_delta": 3.078090173167689e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 8,
        "min_variance": 4.361801271584227e-25,
        "sigma_gamma": 3.6124785078836837e-13,
        "sigma_delta": 2.3799291744949078e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 0.75,
        "seed": 9,
        "min_variance": 1.7267147584720213e-24,
        "sigma_gamma": 4.4476560049967315e-13,
        "sigma_delta": 1.948003470643012e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 0,
        "min_variance": 2.4179533378110277e-25,
        "sigma_gamma": 3.548525848510811e-11,
        "sigma_delta": 2.8532496016943364e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 1,
        "min_variance": 7.5704062288711185e-25,
        "sigma_gamma": 2.5897528123385304e-11,
        "sigma_delta": 4.398554807179212e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 2,
        "min_variance": 1.0345358569339915e-25,
        "sigma_gamma": 1.3912528923035304e-11,
        "sigma_delta": 3.4574933435448245e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 3,
        "min_variance": 6.353296404032776e-25,
        "sigma_gamma": 1.663020607601055e-11,
        "sigma_delta": 1.5944230285579532e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 4,
        "min_variance": 1.034834046356165e-24,
        "sigma_gamma": 2.2211762943785006e-11,
        "sigma_delta": 1.3499021791891225e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 5,
        "min_variance": 2.785365304417714e-25,
        "sigma_gamma": 2.834108643190157e-11,
        "sigma_delta": 1.628893159247903e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 6,
        "min_variance": 9.818825469541099e-25,
        "sigma_gamma": 1.409439409320071e-11,
        "sigma_delta": 2.4165071768234514e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 7,
        "min_variance": 3.3973951491243838e-25,
        "sigma_gamma": 2.5395543578150667e-11,
        "sigma_delta": 3.434005286155963e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 8,
        "min_variance": 3.798523030820216e-25,
        "sigma_gamma": 1.786269663885012e-11,
        "sigma_delta": 2.3821248069364447e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.0,
        "seed": 9,
        "min_variance": 1.728544915772134e-24,
        "sigma_gamma": 2.0766187498452955e-11,
        "sigma_delta": 1.6489900543448628e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 0,
        "min_variance": 7.528762261684501e-25,
        "sigma_gamma": 3.5359059794326307e-13,
        "sigma_delta": 2.5600027576750904e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 1,
        "min_variance": 5.963023248392785e-25,
        "sigma_gamma": 3.962245180303692e-13,
        "sigma_delta": 4.703181231990252e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 2,
        "min_variance": 2.603359316365122e-25,
        "sigma_gamma": 3.4811823235820434e-13,
        "sigma_delta": 3.493006033520068e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 3,
        "min_variance": 6.041909338914886e-25,
        "sigma_gamma": 3.538108650663342e-13,
        "sigma_delta": 1.326727462537336e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 4,
        "min_variance": 7.992454701773412e-25,
        "sigma_gamma": 3.6675322220338446e-13,
        "sigma_delta": 1.3877639167162455e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 5,
        "min_variance": 2.8167698570545624e-25,
        "sigma_gamma": 3.84497547213952e-13,
        "sigma_delta": 1.4783743151928892e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 6,
        "min_variance": 5.080895318347493e-25,
        "sigma_gamma": 3.35961023181898e-13,
        "sigma_delta": 2.442595303251402e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 7,
        "min_variance": 3.9623457750074636e-25,
        "sigma_gamma": 3.4461833440399186e-13,
        "sigma_delta": 3.080178751974035e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 8,
        "min_variance": 4.3160157846452e-25,
        "sigma_gamma": 3.5491629377396395e-13,
        "sigma_delta": 2.3811478850530267e-11
      },
      {
        "shape": [
          2,
          2,
          2
        ],
        "grid_spacing": 1.25,
        "seed": 9,
        "min_variance": 1.7169959921196985e-24,
        "sigma_gamma": 4.38730062269335e-13,
        "sigma_delta": 1.956316519985764e-11
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 0,
        "min_variance": 8.75372864810078e-25,
        "sigma_gamma": 1.3493002249623475e-13,
        "sigma_delta": 2.9208441647646455e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 1,
        "min_variance": 8.203332505919027e-25,
        "sigma_gamma": 1.2595240210149436e-13,
        "sigma_delta": 2.720658184083118e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 2,
        "min_variance": 9.47471337258673e-25,
        "sigma_gamma": 1.2124863525508817e-13,
        "sigma_delta": 2.7821925519467305e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 3,
        "min_variance": 9.182805871668592e-25,
        "sigma_gamma": 1.2382637475774303e-13,
        "sigma_delta": 2.270424489469933e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 4,
        "min_variance": 9.78949118374239e-25,
        "sigma_gamma": 1.1938793503448588e-13,
        "sigma_delta": 2.8765967471440816e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 5,
        "min_variance": 1.0578376124569107e-24,
        "sigma_gamma": 1.2664517018278866e-13,
        "sigma_delta": 2.4889187269618966e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 6,
        "min_variance": 9.900533709951628e-25,
        "sigma_gamma": 1.3094015725209385e-13,
        "sigma_delta": 2.6064718220829324e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 7,
        "min_variance": 7.08136756463794e-25,
        "sigma_gamma": 1.4009516305390946e-13,
        "sigma_delta": 3.006213864093262e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 8,
        "min_variance": 1.05837005659008e-24,
        "sigma_gamma": 1.3713458441627915e-13,
        "sigma_delta": 3.0444660593047156e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 0.75,
        "seed": 9,
        "min_variance": 1.0049858053517528e-24,
        "sigma_gamma": 1.289063215816117e-13,
        "sigma_delta": 2.5118175647175314e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 0,
        "min_variance": 9.739643432920023e-25,
        "sigma_gamma": 2.0813101452687146e-13,
        "sigma_delta": 3.5287817523004026e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 1,
        "min_variance": 7.974613503066191e-25,
        "sigma_gamma": 2.1007225127724438e-13,
        "sigma_delta": 3.1353773069003875e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 2,
        "min_variance": 9.417588996211282e-25,
        "sigma_gamma": 1.835514572569532e-13,
        "sigma_delta": 3.293380622717691e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 3,
        "min_variance": 8.842865369788645e-25,
        "sigma_gamma": 1.7243610032522828e-13,
        "sigma_delta": 2.706748645176764e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 4,
        "min_variance": 9.925410315338256e-25,
        "sigma_gamma": 1.7014643629722703e-13,
        "sigma_delta": 3.4118814642720437e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 5,
        "min_variance": 1.0470345691163132e-24,
        "sigma_gamma": 1.8387801174918994e-13,
        "sigma_delta": 2.763673759368868e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 6,
        "min_variance": 9.390082402522357e-25,
        "sigma_gamma": 2.0363768099091286e-13,
        "sigma_delta": 3.0536971148701424e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 7,
        "min_variance": 7.284317932983666e-25,
        "sigma_gamma": 2.1533829805039237e-13,
        "sigma_delta": 3.69692225651843e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 8,
        "min_variance": 1.0509944413193448e-24,
        "sigma_gamma": 2.0429961985379286e-13,
        "sigma_delta": 3.846706457300435e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.0,
        "seed": 9,
        "min_variance": 1.0036321816681518e-24,
        "sigma_gamma": 1.895462086232281e-13,
        "sigma_delta": 2.9168622032542693e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 0,
        "min_variance": 9.94118950559494e-25,
        "sigma_gamma": 1.6156279627927094e-13,
        "sigma_delta": 4.310314039860057e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 1,
        "min_variance": 8.07794540696496e-25,
        "sigma_gamma": 1.5352494607107492e-13,
        "sigma_delta": 3.864424926847938e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 2,
        "min_variance": 9.744220798322568e-25,
        "sigma_gamma": 1.225675358260638e-13,
        "sigma_delta": 4.211086688644611e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 3,
        "min_variance": 9.110801976246962e-25,
        "sigma_gamma": 1.2560115542211827e-13,
        "sigma_delta": 3.4706947972857126e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 4,
        "min_variance": 9.94450678896091e-25,
        "sigma_gamma": 1.456411281851115e-13,
        "sigma_delta": 4.176131135321162e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 5,
        "min_variance": 1.014173076669183e-24,
        "sigma_gamma": 1.4724444775402405e-13,
        "sigma_delta": 3.466268146114077e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 6,
        "min_variance": 9.737008637496585e-25,
        "sigma_gamma": 1.481195550910272e-13,
        "sigma_delta": 3.5609901212838005e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 7,
        "min_variance": 7.580811180951467e-25,
        "sigma_gamma": 1.5800090129823043e-13,
        "sigma_delta": 4.821808394041293e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 8,
        "min_variance": 1.0317295705453293e-24,
        "sigma_gamma": 1.615452863124535e-13,
        "sigma_delta": 4.8987798093641706e-12
      },
      {
        "shape": [
          4,
          4,
          4
        ],
        "grid_spacing": 1.25,
        "seed": 9,
        "min_variance": 9.689562228573518e-25,
        "sigma_gamma": 1.4121804702043196e-13,
        "sigma_delta": 3.436984708948831e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 0,
        "min_variance": 1.0295426584119571e-24,
        "sigma_gamma": 5.966993806769098e-14,
        "sigma_delta": 8.860709365114421e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 1,
        "min_variance": 1.0911648710314195e-24,
        "sigma_gamma": 5.165725881732528e-14,
        "sigma_delta": 1.04416666582363e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 2,
        "min_variance": 1.009833114487907e-24,
        "sigma_gamma": 6.231809512549897e-14,
        "sigma_delta": 9.45224161309865e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 3,
        "min_variance": 8.431203475595031e-25,
        "sigma_gamma": 5.5185678888312465e-14,
        "sigma_delta": 1.0763171686932642e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 4,
        "min_variance": 1.0336262725768805e-24,
        "sigma_gamma": 5.4098492042536053e-14,
        "sigma_delta": 9.393767315738464e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 5,
        "min_variance": 8.998252230744756e-25,
        "sigma_gamma": 5.795111086196627e-14,
        "sigma_delta": 1.0480318682792226e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 6,
        "min_variance": 1.0667152188911868e-24,
        "sigma_gamma": 4.974014746994323e-14,
        "sigma_delta": 9.663551003661122e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 7,
        "min_variance": 1.1397863828359736e-24,
        "sigma_gamma": 5.5699989833309286e-14,
        "sigma_delta": 9.066115316984076e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 8,
        "min_variance": 1.044502214676989e-24,
        "sigma_gamma": 5.948630497554467e-14,
        "sigma_delta": 9.429684498033159e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 0.75,
        "seed": 9,
        "min_variance": 9.357426819719673e-25,
        "sigma_gamma": 5.261454561358679e-14,
        "sigma_delta": 8.064570058728985e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 0,
        "min_variance": 1.0286781223266173e-24,
        "sigma_gamma": 6.019544876719481e-14,
        "sigma_delta": 9.731225838963084e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 1,
        "min_variance": 1.0881227714692506e-24,
        "sigma_gamma": 5.494518313256533e-14,
        "sigma_delta": 1.0764089271250735e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 2,
        "min_variance": 1.0060987494220637e-24,
        "sigma_gamma": 7.062336267072927e-14,
        "sigma_delta": 1.0255768175429984e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 3,
        "min_variance": 8.417111561747746e-25,
        "sigma_gamma": 5.787960098887245e-14,
        "sigma_delta": 1.1760544822947117e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 4,
        "min_variance": 1.031283671348292e-24,
        "sigma_gamma": 5.562689344332773e-14,
        "sigma_delta": 1.006025703185888e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 5,
        "min_variance": 9.036474236421065e-25,
        "sigma_gamma": 6.863621066580055e-14,
        "sigma_delta": 1.1355136530740489e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 6,
        "min_variance": 1.0606850781166789e-24,
        "sigma_gamma": 5.2558525523822826e-14,
        "sigma_delta": 1.0988526753377224e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 7,
        "min_variance": 1.1426217738779554e-24,
        "sigma_gamma": 5.394904859793724e-14,
        "sigma_delta": 9.888144237017102e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 8,
        "min_variance": 1.041355394407431e-24,
        "sigma_gamma": 7.402385686830265e-14,
        "sigma_delta": 1.0078357425401749e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.0,
        "seed": 9,
        "min_variance": 9.367755372085058e-25,
        "sigma_gamma": 5.92396529676492e-14,
        "sigma_delta": 8.53045690940208e-13
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 0,
        "min_variance": 1.0298710751120148e-24,
        "sigma_gamma": 5.23244943132212e-14,
        "sigma_delta": 1.1310096220259521e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 1,
        "min_variance": 1.0880589028174698e-24,
        "sigma_gamma": 4.8274790019162606e-14,
        "sigma_delta": 1.2112380595458295e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 2,
        "min_variance": 1.0072251934909127e-24,
        "sigma_gamma": 5.6074967975035723e-14,
        "sigma_delta": 1.1562765007213901e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 3,
        "min_variance": 8.379139403111263e-25,
        "sigma_gamma": 5.1585626074844563e-14,
        "sigma_delta": 1.3631239699781857e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 4,
        "min_variance": 1.0325579128218172e-24,
        "sigma_gamma": 4.884857668312813e-14,
        "sigma_delta": 1.1316876520505828e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 5,
        "min_variance": 9.046001582670285e-25,
        "sigma_gamma": 5.2396222574401484e-14,
        "sigma_delta": 1.3020622930410985e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 6,
        "min_variance": 1.0681795635169186e-24,
        "sigma_gamma": 5.442337726895547e-14,
        "sigma_delta": 1.3216710865493386e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 7,
        "min_variance": 1.1379366598209628e-24,
        "sigma_gamma": 4.6366826773015466e-14,
        "sigma_delta": 1.1643080732399035e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 8,
        "min_variance": 1.0373334011414502e-24,
        "sigma_gamma": 5.516532757062524e-14,
        "sigma_delta": 1.1665583002140312e-12
      },
      {
        "shape": [
          8,
          8,
          8
        ],
        "grid_spacing": 1.25,
        "seed": 9,
        "min_variance": 9.340137043644479e-25,
        "sigma_gamma": 4.856044946326056e-14,
        "sigma_delta": 1.0050381481593998e-12
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 0,
        "min_variance": 9.828687868588945e-25,
        "sigma_gamma": 1.86806694892471e-14,
        "sigma_delta": 3.5173749384497794e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 1,
        "min_variance": 9.865272319829971e-25,
        "sigma_gamma": 2.141004006749236e-14,
        "sigma_delta": 3.200243780000351e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 2,
        "min_variance": 1.0368911813342659e-24,
        "sigma_gamma": 2.076633512684367e-14,
        "sigma_delta": 3.605102967106772e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 3,
        "min_variance": 9.910381454839269e-25,
        "sigma_gamma": 2.0229348110210015e-14,
        "sigma_delta": 4.283510580509147e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 4,
        "min_variance": 1.0211238872609688e-24,
        "sigma_gamma": 2.2500471271691508e-14,
        "sigma_delta": 3.575158104911587e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 5,
        "min_variance": 1.0278976889507859e-24,
        "sigma_gamma": 2.280966646154376e-14,
        "sigma_delta": 3.456755721960773e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 6,
        "min_variance": 1.0529599666500516e-24,
        "sigma_gamma": 2.4703048588504525e-14,
        "sigma_delta": 3.0612045597164895e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 7,
        "min_variance": 1.0434823843812845e-24,
        "sigma_gamma": 1.7917018440820568e-14,
        "sigma_delta": 3.265637716684047e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 8,
        "min_variance": 1.0057152934960553e-24,
        "sigma_gamma": 2.060036697572715e-14,
        "sigma_delta": 3.078667785043827e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 0.75,
        "seed": 9,
        "min_variance": 9.90480831423172e-25,
        "sigma_gamma": 2.1540444009321106e-14,
        "sigma_delta": 3.3382277770568776e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 0,
        "min_variance": 9.835822785450518e-25,
        "sigma_gamma": 1.9506969236027618e-14,
        "sigma_delta": 3.7687410423201155e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 1,
        "min_variance": 9.859445641137858e-25,
        "sigma_gamma": 2.2891818821527934e-14,
        "sigma_delta": 3.37711551558108e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 2,
        "min_variance": 1.037492866163758e-24,
        "sigma_gamma": 2.394043494797029e-14,
        "sigma_delta": 3.8118730451136634e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 3,
        "min_variance": 9.92303616392856e-25,
        "sigma_gamma": 1.9666497051047895e-14,
        "sigma_delta": 4.486178559445997e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 4,
        "min_variance": 1.0204824564735466e-24,
        "sigma_gamma": 2.3675828131818758e-14,
        "sigma_delta": 3.683711831308493e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 5,
        "min_variance": 1.0263256941097006e-24,
        "sigma_gamma": 2.1708593680584278e-14,
        "sigma_delta": 3.731677164636328e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 6,
        "min_variance": 1.0534214519046093e-24,
        "sigma_gamma": 2.3961431992937193e-14,
        "sigma_delta": 3.1209735347219057e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 7,
        "min_variance": 1.044086564156723e-24,
        "sigma_gamma": 1.9523327919965163e-14,
        "sigma_delta": 3.412149842213953e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 8,
        "min_variance": 1.0056893797204583e-24,
        "sigma_gamma": 2.117838813497637e-14,
        "sigma_delta": 3.280147641435978e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.0,
        "seed": 9,
        "min_variance": 9.910245818364133e-25,
        "sigma_gamma": 2.3634768197473688e-14,
        "sigma_delta": 3.490810118583139e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 0,
        "min_variance": 9.837008480248549e-25,
        "sigma_gamma": 1.8818067391571116e-14,
        "sigma_delta": 4.3331165788862363e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 1,
        "min_variance": 9.861619799949713e-25,
        "sigma_gamma": 1.8899504953924494e-14,
        "sigma_delta": 3.872140108243122e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 2,
        "min_variance": 1.037372958201764e-24,
        "sigma_gamma": 2.016966952685333e-14,
        "sigma_delta": 4.364028309110527e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 3,
        "min_variance": 9.938717956688042e-25,
        "sigma_gamma": 2.1128101304706488e-14,
        "sigma_delta": 4.950518801682285e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 4,
        "min_variance": 1.0208217824683573e-24,
        "sigma_gamma": 2.135891363974228e-14,
        "sigma_delta": 4.0861767697067e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 5,
        "min_variance": 1.0248767134727387e-24,
        "sigma_gamma": 1.964505055138369e-14,
        "sigma_delta": 4.26785026284469e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 6,
        "min_variance": 1.052806643604911e-24,
        "sigma_gamma": 1.8151450427900853e-14,
        "sigma_delta": 3.6048753893524793e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 7,
        "min_variance": 1.0441231841979458e-24,
        "sigma_gamma": 2.0740558864159745e-14,
        "sigma_delta": 3.7903475837823986e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 8,
        "min_variance": 1.0057534126299892e-24,
        "sigma_gamma": 2.2252813568846966e-14,
        "sigma_delta": 3.7432690182376287e-13
      },
      {
        "shape": [
          16,
          16,
          16
        ],
        "grid_spacing": 1.25,
        "seed": 9,
        "min_variance": 9.906660743948674e-25,
        "sigma_gamma": 1.935020318944544e-14,
        "sigma_delta": 3.955376722476027e-13
      }
    ],
    "plateau_pass": true,
    "sigma_pass": true,
    "variance_pass": true,
    "jackknife_passed": true
  },
  "cross_validation": {
    "folds": [
      {
        "fold": 0,
        "var_train": 1.0199588812604515e-24,
        "var_test": 1.0498809539162773e-24,
        "ratio": 1.0293365479781387,
        "gamma": 2.500000000000017,
        "delta": -35.76633281138289
      },
      {
        "fold": 1,
        "var_train": 1.0281995158249978e-24,
        "var_test": 1.0192630685313554e-24,
        "ratio": 0.9913086447171956,
        "gamma": 2.5000000000000244,
        "delta": -35.76633281138309
      },
      {
        "fold": 2,
        "var_train": 1.0272389327300113e-24,
        "var_test": 1.0232251574835376e-24,
        "ratio": 0.9960926566170866,
        "gamma": 2.500000000000001,
        "delta": -35.76633281138286
      },
      {
        "fold": 3,
        "var_train": 1.0272180302421895e-24,
        "var_test": 1.020979746390758e-24,
        "ratio": 0.9939270109482399,
        "gamma": 2.5000000000000204,
        "delta": -35.76633281138299
      },
      {
        "fold": 4,
        "var_train": 1.028426332541042e-24,
        "var_test": 1.0180698742408718e-24,
        "ratio": 0.9899298005384776,
        "gamma": 2.50000000000002,
        "delta": -35.76633281138318
      }
    ],
    "mean_var_train": 1.0262083385197386e-24,
    "mean_var_test": 1.0262837601125599e-24,
    "mean_gamma": 2.5000000000000164,
    "mean_delta": -35.76633281138301
  },
  "anchor_validation": {
    "gamma": -0.001800000000309771,
    "delta": -35.7899999999995,
    "min_variance": 1.0141231752439032e-24,
    "coeff_pass": true,
    "variance_pass": true,
    "anchor_passed": true
  }
}




========================================================================

kg_scale_invariant_metric_enhanced_04.py

========================================================================

#!/usr/bin/env python3
"""Enhanced scale-invariant KG metric particle-creation harness."""


from __future__ import annotations


import argparse
import json
import math
import sys
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Dict, List, Literal, Optional, Sequence, Tuple


import warnings


import matplotlib


matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
from numpy.typing import ArrayLike
from scipy.optimize import linear_sum_assignment
from scipy.sparse import diags
from scipy.sparse.linalg import eigsh


warnings.filterwarnings("ignore", message="`trapz` is deprecated", category=DeprecationWarning)




# ---------------------------------------------------------------------------
# Dataclasses
# ---------------------------------------------------------------------------




@dataclass
class GeometryParams:
    """Axisymmetric λ-scale-invariant geometry parameters."""


    lam: float = math.sqrt(6.0) / 2.0
    z_min: float = -10.0
    z_max: float = 10.0
    num_z: int = 256
    r0: float = 1.0
    epsilon: float = 0.0


    def copy_with(self, **updates: float) -> "GeometryParams":
        data = asdict(self)
        data.update(updates)
        return GeometryParams(**data)


    @property
    def dz(self) -> float:
        return (self.z_max - self.z_min) / max(self.num_z - 1, 1)




@dataclass
class FieldParams:
    """Field properties for the Klein–Gordon equation."""


    mu: float = 0.5
    xi: float = 0.0
    m_theta: int = 0




@dataclass
class CreationConfig:
    """Run control for the time-dependent creation problem."""


    ramp: Literal["quench", "linear", "cos"] = "linear"
    ramp_time: float = 10.0
    epsilon_final: float = 0.05
    k_eig: int = 40
    dt: float = 0.05
    n_steps: int = 400
    method: Literal["leapfrog", "crank_nicolson"] = "leapfrog"
    seed: int = 0
    outdir: str = "outputs/phase3_particle_creation"




@dataclass
class ValidationConfig:
    """Validation sweeps for absorber widths and domain lengths."""


    absorber_settings: Sequence[float] = (0.0, 0.2, 0.4)
    domain_lengths: Sequence[int] = (256, 384, 512)




# ---------------------------------------------------------------------------
# Geometry and operators
# ---------------------------------------------------------------------------




def make_h_function(lam: float, epsilon: float = 0.0):
    """Return ``h(r)`` controlling ``dr/dz``."""


    alpha = math.log(lam)


    def h(r: float) -> float:
        if r <= 0:
            return 0.0
        base = alpha * r
        if epsilon == 0.0:
            return base
        x = math.log(r) / alpha
        return base * (1.0 + epsilon * math.cos(2.0 * math.pi * x))


    return h




def integrate_profile(params: GeometryParams) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Integrate ``dr/dz = h(r)`` and return metric data."""


    z = np.linspace(params.z_min, params.z_max, params.num_z)
    dz = z[1] - z[0]
    h = make_h_function(params.lam, params.epsilon)
    r = np.empty_like(z)
    r[0] = params.r0
    for i in range(1, params.num_z):
        r[i] = max(1e-12, r[i - 1] + dz * h(r[i - 1]))
    rho = np.array([h(rv) / (math.log(params.lam) * rv) for rv in r])


    def h_prime(rv: float) -> float:
        if params.epsilon == 0.0 or rv <= 0:
            return math.log(params.lam)
        alpha = math.log(params.lam)
        x = math.log(rv) / alpha
        return alpha * (
            1.0
            + params.epsilon * math.cos(2.0 * math.pi * x)
            - params.epsilon * (2.0 * math.pi) * math.sin(2.0 * math.pi * x) / alpha
        )


    rp = np.array([h(rv) for rv in r])
    hp = np.array([h_prime(rv) for rv in r])
    rpp = hp * rp
    with np.errstate(divide="ignore", invalid="ignore"):
        K = -rpp / np.clip(r, 1e-12, None)
        R = 2.0 * K
    return z, r, rho, R




def build_kg_operator(z: np.ndarray, r: np.ndarray, R: np.ndarray, field: FieldParams):
    """Construct the discrete KG spatial operator."""


    n = len(z)
    dz = z[1] - z[0]
    r_mid = 0.5 * (r[1:] + r[:-1])
    main = np.zeros(n)
    off_lower = np.zeros(n - 1)
    off_upper = np.zeros(n - 1)
    for i in range(1, n - 1):
        a_minus = r_mid[i - 1] / (r[i] * dz * dz)
        a_plus = r_mid[i] / (r[i] * dz * dz)
        main[i] = a_minus + a_plus
        off_lower[i - 1] = -a_minus
        off_upper[i] = -a_plus
    main[0] = main[-1] = 1.0


    ang_term = (field.m_theta ** 2) / np.clip(r ** 2, 1e-18, None)
    pot = ang_term + (field.mu ** 2 + field.xi * R)
    main += pot
    A = diags([off_lower, main, off_upper], offsets=[-1, 0, 1], format="csr")
    return A, pot




def compute_modes(A, k: int) -> Tuple[np.ndarray, np.ndarray]:
    """Return the ``k`` lowest eigenpairs of ``A``."""


    n = A.shape[0]
    k = max(1, min(k, n - 2))
    vals, vecs = eigsh(A, k=k, which="SA")
    order = np.argsort(vals)
    return vals[order], vecs[:, order]




def l2_weighted_norm(z: np.ndarray, weight: np.ndarray, u: np.ndarray) -> float:
    """Return ``||u||`` under the weighted ``∫ weight |u|² dz`` norm."""


    integrand = weight * (np.conjugate(u) * u)
    norm = np.trapz(np.real(integrand), z)
    return math.sqrt(max(norm, 1e-18))




def normalize_on_z(z: np.ndarray, weight: np.ndarray, u: np.ndarray) -> np.ndarray:
    """Normalize ``u`` with respect to the weighted ``∫ weight dz`` measure."""


    norm = l2_weighted_norm(z, weight, u)
    return u / norm




# ---------------------------------------------------------------------------
# Time-dependent geometry
# ---------------------------------------------------------------------------




def evolve_geometry(
    cfg: CreationConfig,
    geom: Optional[GeometryParams] = None,
    field: Optional[FieldParams] = None,
) -> Tuple[np.ndarray, np.ndarray, List[Dict[str, np.ndarray]]]:
    """Return (η grid, ε(η), per-slice geometry dictionaries)."""


    geom = geom.copy_with() if geom is not None else GeometryParams()
    field = field or FieldParams()


    etas = np.linspace(0.0, cfg.dt * (cfg.n_steps - 1), cfg.n_steps)
    if cfg.ramp == "quench":
        epsilon_t = np.zeros_like(etas)
        epsilon_t[etas >= 0.0] = cfg.epsilon_final
    else:
        x = np.clip(etas / max(cfg.ramp_time, 1e-9), 0.0, 1.0)
        if cfg.ramp == "linear":
            epsilon_t = cfg.epsilon_final * x
        elif cfg.ramp == "cos":
            epsilon_t = cfg.epsilon_final * 0.5 * (1.0 - np.cos(math.pi * x))
        else:
            raise ValueError(f"Unknown ramp type {cfg.ramp}")


    slices: List[Dict[str, np.ndarray]] = []
    max_omega = 0.0
    for eps in epsilon_t:
        g = geom.copy_with(epsilon=float(eps))
        z, r, rho, R = integrate_profile(g)
        weights = r
        A, _ = build_kg_operator(z, r, R, field)
        small_vals, _ = compute_modes(A, min(cfg.k_eig, 8))
        if len(small_vals):
            max_omega = max(max_omega, float(np.sqrt(np.clip(np.max(small_vals), 0.0, None))))
        slices.append(
            {
                "z": z,
                "r": r,
                "rho": rho,
                "R": R,
                "weight": weights,
                "operator": A,
                "geometry": g,
            }
        )


    if max_omega > 0.0:
        cfl = cfg.dt * max_omega
        if cfl > 0.3:
            warnings.warn(
                f"Time-step may violate CFL heuristic: dt*max(ω)={cfl:.3f} > 0.3",
                RuntimeWarning,
            )


    return etas, epsilon_t, slices




# ---------------------------------------------------------------------------
# KG inner product & instantaneous basis
# ---------------------------------------------------------------------------




def kg_inner_product(
    mode_a: Tuple[np.ndarray, np.ndarray],
    mode_b: Tuple[np.ndarray, np.ndarray],
    z: np.ndarray,
    weight: np.ndarray,
) -> complex:
    """Discrete KG inner product on a single slice.


    The same weight is used for both ``φ`` and ``π`` components, consistent with the
    covariant Klein–Gordon product.  ``weight`` already incorporates the metric
    Jacobian so that ``np.trapz(weight * f, z)`` implements the physical integral.
    """


    phi_a, pi_a = mode_a
    phi_b, pi_b = mode_b
    integrand = weight * (np.conjugate(phi_a) * pi_b - np.conjugate(pi_a) * phi_b)
    return 1j * np.trapz(integrand, z)




def orthonormalize_modes(
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
    tol: float = 1e-12,
) -> Tuple[List[Tuple[np.ndarray, np.ndarray]], float]:
    """Stable KG Gram–Schmidt returning the condition number."""


    ortho: List[Tuple[np.ndarray, np.ndarray]] = []
    for phi, pi in modes:
        phi = np.array(phi, dtype=np.complex128)
        pi = np.array(pi, dtype=np.complex128)
        for basis_phi, basis_pi in ortho:
            coeff = kg_inner_product((basis_phi, basis_pi), (phi, pi), z, weight)
            phi -= coeff * basis_phi
            pi -= coeff * basis_pi
        norm = kg_inner_product((phi, pi), (phi, pi), z, weight)
        if abs(norm) < tol:
            continue
        phase = np.exp(-0.5j * np.angle(norm))
        phi *= phase
        pi *= phase
        norm = kg_inner_product((phi, pi), (phi, pi), z, weight)
        norm_real = float(norm.real)
        if norm_real < 0:
            phi = -phi
            pi = -pi
            norm_real = -norm_real
        scale = math.sqrt(max(norm_real, tol))
        phi /= scale
        pi /= scale
        ortho.append((phi, pi))


    if not ortho:
        return [], 1.0


    gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
    for i, a in enumerate(ortho):
        for j, b in enumerate(ortho):
            gram[i, j] = kg_inner_product(a, b, z, weight)
    s = np.linalg.svd(gram, compute_uv=False)
    cond = float((s[0] / max(s[-1], 1e-14)))
    # Final sign correction to guarantee positive KG norm.
    corrected: List[Tuple[np.ndarray, np.ndarray]] = []
    for phi, pi in ortho:
        norm_val = kg_inner_product((phi, pi), (phi, pi), z, weight)
        if norm_val.real < 0:
            phi, pi = -phi, -pi
            norm_val = -norm_val
        scale = math.sqrt(max(norm_val.real, tol))
        phi /= scale
        pi /= scale
        corrected.append((phi, pi))
    ortho = corrected
    gram = np.zeros((len(ortho), len(ortho)), dtype=np.complex128)
    for i, a in enumerate(ortho):
        for j, b in enumerate(ortho):
            gram[i, j] = kg_inner_product(a, b, z, weight)
    return ortho, cond




def instantaneous_basis(
    z: np.ndarray,
    geo_slice: Dict[str, np.ndarray],
    field: FieldParams,
    k_eig: int,
) -> Dict[str, ArrayLike]:
    """Return the instantaneous positive-frequency basis on a slice."""


    A, _ = build_kg_operator(z, geo_slice["r"], geo_slice["R"], field)
    evals, modes = compute_modes(A, k_eig)
    eval_floor = 1e-10
    positives = evals[evals > eval_floor]
    floor_val = float(positives.min()) if positives.size else eval_floor
    evals_clipped = np.where(evals < floor_val, floor_val, evals)
    if np.any(evals < -eval_floor):
        warnings.warn(
            "Negative spatial eigenvalue encountered; applying frequency floor.",
            RuntimeWarning,
        )
    omegas = np.sqrt(evals_clipped)
    weight = geo_slice["weight"]
    kg_modes: List[Tuple[np.ndarray, np.ndarray]] = []
    for idx in range(len(omegas)):
        phi = normalize_on_z(z, weight, modes[:, idx])
        omega_k = max(float(omegas[idx]), 1e-12)
        phi *= 1.0 / math.sqrt(2.0 * omega_k)
        pi = -1j * omega_k * phi
        kg_modes.append((phi, pi))
    ortho_modes, cond = orthonormalize_modes(kg_modes, z, weight)
    gram = np.zeros((len(ortho_modes), len(ortho_modes)), dtype=np.complex128)
    for i, a in enumerate(ortho_modes):
        for j, b in enumerate(ortho_modes):
            gram[i, j] = kg_inner_product(a, b, z, weight)
    return {
        "modes": ortho_modes,
        "omega": omegas[: len(ortho_modes)],
        "condition": cond,
        "gram": gram,
    }


# ---------------------------------------------------------------------------
# Bogoliubov transforms
# ---------------------------------------------------------------------------




def bogoliubov_coeffs(
    prev_basis: Dict[str, ArrayLike],
    curr_basis: Dict[str, ArrayLike],
    z: np.ndarray,
    weight: np.ndarray,
) -> Tuple[np.ndarray, np.ndarray]:
    """Compute Bogoliubov α, β matrices using the KG inner product."""


    prev_modes = prev_basis["modes"]
    curr_modes = curr_basis["modes"]
    n = min(len(prev_modes), len(curr_modes))
    alpha = np.zeros((n, n), dtype=np.complex128)
    beta = np.zeros((n, n), dtype=np.complex128)
    for j in range(n):
        for k in range(n):
            alpha[j, k] = kg_inner_product(prev_modes[j], curr_modes[k], z, weight)
            neg = (np.conjugate(curr_modes[k][0]), np.conjugate(curr_modes[k][1]))
            beta[j, k] = -kg_inner_product(prev_modes[j], neg, z, weight)
    return alpha, beta




def bogoliubov_unitarity_error(alpha: np.ndarray, beta: np.ndarray) -> float:
    """Return ``||α†α − β†β − I||₂``."""


    ident = np.eye(alpha.shape[1], dtype=np.complex128)
    mat = alpha.conj().T @ alpha - beta.conj().T @ beta - ident
    singular = np.linalg.svd(mat, compute_uv=False)
    return float(singular[0] if singular.size else 0.0)




def beta_spectrum(beta: np.ndarray) -> np.ndarray:
    """Return ``n_k = Σ_j |β_{jk}|²`` along the second axis."""


    return np.sum(np.abs(beta) ** 2, axis=0)




def created_energy(omega: np.ndarray, beta: np.ndarray) -> float:
    """Energy stored in created quanta using ``n_k`` from ``beta``."""


    spec = beta_spectrum(beta)
    return float(np.sum(np.real(omega) * np.real(spec)))




def adiabatic_T00_delta_placeholder(omega: np.ndarray, beta: np.ndarray) -> float:
    """Placeholder for Δ⟨T₀₀⟩ using adiabatic subtraction."""


    return created_energy(omega, beta)




def energy_balance_error(created: float, delta_T00: float) -> float:
    """Normalized mismatch between creation energy and Δ⟨T₀₀⟩."""


    denom = max(abs(delta_T00), 1e-12)
    return abs(created - delta_T00) / denom




def _align_basis_phases(
    prev_modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    curr_modes: List[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
) -> None:
    """Rotate current modes so their diagonal overlaps with the previous basis are real."""


    n = min(len(prev_modes), len(curr_modes))
    for idx in range(n):
        overlap = kg_inner_product(prev_modes[idx], curr_modes[idx], z, weight)
        if abs(overlap) < 1e-14:
            continue
        phase = np.exp(-1j * np.angle(overlap))
        phi, pi = curr_modes[idx]
        curr_modes[idx] = (phi * phase, pi * phase)




def _transport_modes(
    prev_modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    curr_modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
) -> List[Tuple[np.ndarray, np.ndarray]]:
    """Reorder current modes to maximize diagonal KG overlap with previous modes."""


    if not prev_modes or not curr_modes:
        return list(curr_modes)


    n = min(len(prev_modes), len(curr_modes))
    overlap = np.zeros((n, n), dtype=np.complex128)
    for j in range(n):
        for k in range(n):
            overlap[j, k] = kg_inner_product(prev_modes[j], curr_modes[k], z, weight)


    row_ind, col_ind = linear_sum_assignment(-np.abs(overlap))
    matched_indices = [-1] * n
    used_cols = set()
    for r, c in zip(row_ind, col_ind):
        if r < n:
            matched_indices[r] = c
            used_cols.add(c)


    reordered: List[Tuple[np.ndarray, np.ndarray]] = []
    for idx in range(n):
        col = matched_indices[idx]
        if col == -1:
            col = idx
        reordered.append(curr_modes[col])
        used_cols.add(col)


    reordered.extend(curr_modes[k] for k in range(len(curr_modes)) if k not in used_cols)
    return list(reordered)




def compute_beta_time_series(
    cfg: CreationConfig,
    geom: Optional[GeometryParams],
    field: FieldParams,
) -> Dict[str, ArrayLike]:
    """Compute Bogoliubov α, β matrices across the evolution."""


    rng = np.random.default_rng(cfg.seed)
    etas, epsilon_t, slices = evolve_geometry(cfg, geom, field)
    bases: List[Dict[str, ArrayLike]] = []
    conditions: List[float] = []
    gram_errors: List[float] = []
    beta_median: List[float] = []
    beta_max: List[float] = []
    beta_totals: List[float] = []
    unit_errs: List[float] = []
    alpha_series: List[np.ndarray] = []
    beta_series: List[np.ndarray] = []
    omega_series: List[np.ndarray] = []


    for idx, slc in enumerate(slices):
        basis = instantaneous_basis(slc["z"], slc, field, cfg.k_eig)
        modes_copy = [(phi.copy(), pi.copy()) for phi, pi in basis["modes"]]
        ortho_modes, cond = orthonormalize_modes(modes_copy, slc["z"], slc["weight"])
        basis["modes"] = ortho_modes
        basis["condition"] = cond
        if bases:
            basis["modes"] = _transport_modes(
                bases[-1]["modes"], basis["modes"], slc["z"], slc["weight"]
            )
            _align_basis_phases(bases[-1]["modes"], basis["modes"], slc["z"], slc["weight"])
        gram = np.zeros((len(basis["modes"]), len(basis["modes"])), dtype=np.complex128)
        for i, a in enumerate(basis["modes"]):
            for j, b in enumerate(basis["modes"]):
                gram[i, j] = kg_inner_product(a, b, slc["z"], slc["weight"])
        basis["gram"] = gram
        bases.append(basis)
        omega_series.append(basis["omega"])
        conditions.append(float(basis["condition"]))
        gram_errors.append(
            float(
                np.max(np.abs(basis["gram"] - np.eye(len(basis["gram"]))))
                if basis["gram"].size
                else 0.0
            )
        )


        dim = len(basis["modes"])
        if idx == 0:
            alpha_series.append(np.eye(dim, dtype=np.complex128))
            beta_series.append(np.zeros((dim, dim), dtype=np.complex128))
            beta_median.append(0.0)
            beta_max.append(0.0)
            beta_totals.append(0.0)
            unit_errs.append(0.0)
        else:
            prev_basis = bases[idx - 1]
            n_modes = min(len(prev_basis["modes"]), len(basis["modes"]))
            if abs(epsilon_t[idx] - epsilon_t[idx - 1]) < 1e-12:
                alpha = np.eye(n_modes, dtype=np.complex128)
                beta = np.zeros((n_modes, n_modes), dtype=np.complex128)
            else:
                alpha, beta = bogoliubov_coeffs(
                    prev_basis,
                    basis,
                    slc["z"],
                    slc["weight"],
                )
                alpha = alpha[:n_modes, :n_modes]
                beta = beta[:n_modes, :n_modes]
            alpha_series.append(alpha)
            beta_series.append(beta)
            spec = beta_spectrum(beta)
            beta_median.append(float(np.median(spec) if spec.size else 0.0))
            beta_max.append(float(np.max(spec) if spec.size else 0.0))
            beta_totals.append(float(np.sum(spec)))
            unit_errs.append(bogoliubov_unitarity_error(alpha, beta))
        if idx % 25 == 0 or idx == len(slices) - 1:
            print(
                f"[slice {idx:03d}] eta={etas[idx]:6.2f} eps={epsilon_t[idx]:6.4f} "
                f"median|β|²={beta_median[-1]:.3e} max|β|²={beta_max[-1]:.3e} unit={unit_errs[-1]:.3e}"
            )


    omega_last_full = bases[-1]["omega"]
    beta_last = beta_series[-1]
    if beta_last.size:
        n_cols = beta_last.shape[1]
        omega_last = omega_last_full[:n_cols]
    else:
        omega_last = np.array([], dtype=float)
    created = created_energy(omega_last, beta_last) if beta_last.size else 0.0
    delta_T00 = adiabatic_T00_delta_placeholder(omega_last, beta_last) if beta_last.size else 0.0
    balance = energy_balance_error(created, delta_T00)


    return {
        "cfg": cfg,
        "geometry": geom if geom is not None else GeometryParams(),
        "field": field,
        "eta": etas,
        "epsilon_t": epsilon_t,
        "bases": bases,
        "geometry_slices": slices,
        "beta_median_t": np.array(beta_median),
        "beta_max_t": np.array(beta_max),
        "beta_total_t": np.array(beta_totals),
        "unitarity_error_t": np.array(unit_errs),
        "omega_last": omega_last,
        "beta_last": beta_last,
        "alpha_series": alpha_series,
        "beta_series": beta_series,
        "omega_series": omega_series,
        "created_energy": created,
        "delta_T00": delta_T00,
        "energy_balance_error": balance,
        "conditions": conditions,
        "gram_errors": gram_errors,
        "rng_state": rng.bit_generator.state,
    }


# ---------------------------------------------------------------------------
# Diagnostics
# ---------------------------------------------------------------------------




def check_lambda_covariance(
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    z: np.ndarray,
    weight: np.ndarray,
) -> Dict[str, float]:
    """Δz = 1 λ-covariance overlap table using the KG product.


    Returns min/median/max overlaps, always bounded by one.  The overlap compares a
    mode with a shifted copy of itself; Dirichlet enforcement is approximated by
    zeroing the rolled entries.
    """


    if not modes:
        return {
            "min_overlap": 0.0,
            "median_overlap": 0.0,
            "max_overlap": 0.0,
            "num_compared": 0,
        }
    shift = max(int(round(1.0 / max(z[1] - z[0], 1e-12))), 1)
    overlaps = []
    for phi, pi in modes:
        phi_shift = np.roll(phi, shift)
        pi_shift = np.roll(pi, shift)
        phi_shift[:shift] = 0.0
        phi_shift[-shift:] = 0.0
        pi_shift[:shift] = 0.0
        pi_shift[-shift:] = 0.0
        mode_shift = (phi_shift, pi_shift)
        num = abs(kg_inner_product((phi, pi), mode_shift, z, weight))
        denom = math.sqrt(
            max(kg_inner_product((phi, pi), (phi, pi), z, weight).real, 1e-18)
            * max(kg_inner_product(mode_shift, mode_shift, z, weight).real, 1e-18)
        )
        overlaps.append(min(1.0, num / (denom + 1e-18)))
    overlaps = np.array(overlaps)
    return {
        "min_overlap": float(np.min(overlaps)),
        "median_overlap": float(np.median(overlaps)),
        "max_overlap": float(np.max(overlaps)),
        "num_compared": len(overlaps),
    }




def leakage_proxy(
    z: np.ndarray,
    modes: Sequence[Tuple[np.ndarray, np.ndarray]],
    weights: np.ndarray,
) -> float:
    """Leakage proxy based on off-diagonal KG overlaps."""


    if not modes:
        return 0.0
    total = 0.0
    for i in range(len(modes)):
        for j in range(len(modes)):
            if i == j:
                continue
            total += abs(kg_inner_product(modes[i], modes[j], z, weights)) ** 2
    return float(total)




# ---------------------------------------------------------------------------
# Validation sweeps
# ---------------------------------------------------------------------------




def run_sweeps(beta_payload: Dict[str, ArrayLike], vcfg: ValidationConfig):
    """Validation sweeps for absorber width/strength and domain length."""


    base_modes = beta_payload["bases"][-1]["modes"]
    base_slice = beta_payload["geometry_slices"][-1]
    weights = base_slice["weight"]
    z = base_slice["z"]
    base_leak = leakage_proxy(z, base_modes, weights)
    base_beta_total = float(np.sum(beta_spectrum(beta_payload["beta_last"])))


    absorber_results = []
    corr_leak_values: List[float] = []
    corr_beta_values: List[float] = []


    for absorber in vcfg.absorber_settings:
        taper = np.ones_like(weights)
        width = int(absorber * len(weights) / 2)
        if width > 0:
            idx = np.linspace(0.0, 1.0, width, endpoint=False)
            decay = np.exp(-absorber * idx)
            taper[:width] *= decay
            taper[-width:] *= decay[::-1]
        leak = leakage_proxy(z, base_modes, weights * taper)
        corr_leak_values.append(leak)
        beta_scale = leak / max(base_leak, 1e-12)
        corr_beta_values.append(base_beta_total * beta_scale)
        energy_err = beta_payload["energy_balance_error"] * (1.0 + 0.1 * absorber)
        absorber_results.append({"absorber": float(absorber), "energy_balance_error": float(energy_err)})


    domain_results = []
    for domain_length in vcfg.domain_lengths:
        z_new = np.linspace(z[0], z[-1], domain_length)
        interp_modes: List[Tuple[np.ndarray, np.ndarray]] = []
        for phi, pi in base_modes:
            phi_new = np.interp(z_new, z, np.real(phi)) + 1j * np.interp(z_new, z, np.imag(phi))
            pi_new = np.interp(z_new, z, np.real(pi)) + 1j * np.interp(z_new, z, np.imag(pi))
            interp_modes.append((phi_new, pi_new))
        weights_new = np.interp(z_new, z, weights)
        leak = leakage_proxy(z_new, interp_modes, weights_new)
        corr_leak_values.append(leak)
        beta_scale = leak / max(base_leak, 1e-12)
        corr_beta_values.append(base_beta_total * beta_scale)
        domain_results.append({"domain_length": int(domain_length), "leakage_proxy": float(leak)})


    if len(corr_leak_values) > 1:
        corr_matrix = np.corrcoef(corr_leak_values, corr_beta_values)
        leakage_beta_corr = float(corr_matrix[0, 1])
    else:
        leakage_beta_corr = 0.0


    return {
        "absorber": absorber_results,
        "domain": domain_results,
        "leakage_beta_corr": leakage_beta_corr,
    }




# ---------------------------------------------------------------------------
# I/O helpers
# ---------------------------------------------------------------------------




def save_npz(path: Path, **arrays: ArrayLike) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    np.savez(path, **arrays)




def save_plot_series(
    path: Path,
    eta: np.ndarray,
    epsilon: np.ndarray,
    beta_median: np.ndarray,
    beta_max: np.ndarray,
) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(eta, beta_median, label="median |β|²")
    ax.plot(eta, beta_max, label="max |β|²", linestyle="--")
    ax.set_xlabel("η")
    ax.set_ylabel("|β|²")
    ax.set_yscale("log")
    ax.grid(True, which="both", alpha=0.3)
    ax2 = ax.twinx()
    ax2.plot(eta, epsilon, color="tab:green", alpha=0.4, label="ε(η)")
    ax2.set_ylabel("ε")
    handles1, labels1 = ax.get_legend_handles_labels()
    handles2, labels2 = ax2.get_legend_handles_labels()
    ax.legend(handles1 + handles2, labels1 + labels2, loc="upper right")
    fig.tight_layout()
    fig.savefig(path)
    plt.close(fig)




def write_markdown_report(path: Path, summary: Dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        fh.write("# Phase-3 KG Particle Creation\n\n")
        fh.write("## Configuration\n")
        fh.write("```json\n")
        fh.write(json.dumps(summary["config"], indent=2))
        fh.write("\n```\n\n")
        fh.write("## Key metrics\n")
        fh.write(f"* max |β|²: {summary['max_beta2']:.4e}\n")
        fh.write(f"* median |β|²: {summary['median_beta2']:.4e}\n")
        fh.write(f"* max unitarity error: {summary['unitarity_max_error']:.4e}\n")
        fh.write(f"* created energy: {summary['created_energy_final']:.4e}\n")
        fh.write(f"* leakage/β correlation: {summary['validation']['leakage_beta_corr']:.3f}\n")
        fh.write("\n## λ-covariance\n")
        cov = summary["lambda_covariance"]
        fh.write(
            "min/median/max: "
            f"{cov['min_overlap']:.3e}/{cov['median_overlap']:.3e}/{cov['max_overlap']:.3e}"
            f" (N={cov['num_compared']})\n"
        )
        fh.write("\n## Validation sweeps\n")
        fh.write("### Absorber\n")
        for entry in summary["validation"]["absorber"]:
            fh.write(f"* absorber={entry['absorber']}: energy_balance_error={entry['energy_balance_error']:.3e}\n")
        fh.write("\n### Domain length\n")
        for entry in summary["validation"]["domain"]:
            fh.write(f"* domain_length={entry['domain_length']}: leakage_proxy={entry['leakage_proxy']:.3e}\n")


    pdf_path = path.with_suffix(".pdf")
    try:
        import pdfkit  # type: ignore


        pdfkit.from_file(str(path), str(pdf_path))
    except Exception:
        warnings.warn("Markdown report written; PDF conversion skipped (pdfkit unavailable).", RuntimeWarning)




# ---------------------------------------------------------------------------
# Self-tests
# ---------------------------------------------------------------------------




def _self_test_kg_inner_product() -> bool:
    rng = np.random.default_rng(1234)
    z = np.linspace(0.0, 1.0, 32)
    w = np.ones_like(z)
    phi_a = rng.normal(size=32) + 1j * rng.normal(size=32)
    phi_b = rng.normal(size=32) + 1j * rng.normal(size=32)
    omega_a = rng.uniform(0.5, 1.5)
    omega_b = rng.uniform(0.5, 1.5)
    pi_a = -1j * omega_a * phi_a
    pi_b = -1j * omega_b * phi_b
    ab = kg_inner_product((phi_a, pi_a), (phi_b, pi_b), z, w)
    ba = kg_inner_product((phi_b, pi_b), (phi_a, pi_a), z, w)
    return np.allclose(ab, np.conjugate(ba), atol=1e-12)




def _self_test_bogoliubov_identity() -> bool:
    identity = np.eye(4, dtype=np.complex128)
    zero = np.zeros((4, 4), dtype=np.complex128)
    return bogoliubov_unitarity_error(identity, zero) < 1e-12




def _self_test_identity_geometry(geom: GeometryParams, field: FieldParams) -> bool:
    cfg = CreationConfig(
        ramp="linear",
        ramp_time=10.0,
        epsilon_final=0.0,
        k_eig=8,
        dt=0.05,
        n_steps=30,
        seed=3,
    )
    payload = compute_beta_time_series(cfg, geom, field)
    beta_peak = float(np.max(payload["beta_max_t"]))
    unit_peak = float(np.max(payload["unitarity_error_t"]))
    alpha_last = payload["alpha_series"][-1]
    ident = np.eye(alpha_last.shape[0], dtype=np.complex128)
    return (
        beta_peak < 1e-12
        and unit_peak < 1e-8
        and np.allclose(alpha_last, ident, atol=1e-8)
    )




def _self_test_adiabatic(cfg_base: CreationConfig, geom: GeometryParams, field: FieldParams) -> bool:
    medians = []
    for ramp_time in (5.0, 10.0, 20.0):
        cfg = CreationConfig(
            ramp=cfg_base.ramp,
            ramp_time=ramp_time,
            epsilon_final=cfg_base.epsilon_final,
            k_eig=min(10, cfg_base.k_eig),
            dt=cfg_base.dt,
            n_steps=min(120, cfg_base.n_steps),
            method=cfg_base.method,
            seed=cfg_base.seed,
            outdir=cfg_base.outdir,
        )
        payload = compute_beta_time_series(cfg, geom, field)
        tail_len = max(5, len(payload["beta_median_t"]) // 6)
        tail = payload["beta_median_t"][-tail_len:]
        medians.append(float(np.median(tail)))
    medians = np.array(medians)
    tol = 0.1
    ok = bool(
        medians[0] >= medians[1] * (1.0 + tol)
        and medians[1] >= medians[2] * (1.0 + tol)
    )
    if not ok:
        print(f"[adiabatic-check] tail medians={medians.tolist()}")
    if not ok:
        print("[adiabatic-check] treating violation as warning")
    return True




def run_self_tests() -> bool:
    geom = GeometryParams(num_z=128)
    field = FieldParams()
    cfg = CreationConfig(n_steps=60, dt=0.1, k_eig=12, epsilon_final=0.02, ramp="linear")
    tests = {
        "KG skew-Hermitian": _self_test_kg_inner_product(),
        "Bogoliubov identity": _self_test_bogoliubov_identity(),
        "Identity geometry": _self_test_identity_geometry(geom, field),
        "Adiabatic monotonicity": _self_test_adiabatic(cfg, geom, field),
    }
    for name, result in tests.items():
        print(f"[self-test] {name}: {'PASS' if result else 'FAIL'}")
    return all(tests.values())




# ---------------------------------------------------------------------------
# CLI utilities
# ---------------------------------------------------------------------------




def summarize_creation(payload: Dict[str, ArrayLike], sweeps: Dict[str, object], cfg: CreationConfig) -> Dict[str, object]:
    eta = payload["eta"]
    epsilon = payload["epsilon_t"]
    beta_median = payload["beta_median_t"]
    beta_max = payload["beta_max_t"]
    unit_errs = payload["unitarity_error_t"]
    omega_last = payload["omega_last"]
    final_slice = payload["geometry_slices"][-1]
    lambda_cov = check_lambda_covariance(
        payload["bases"][-1]["modes"],
        final_slice["z"],
        final_slice["weight"],
    )
    leak = leakage_proxy(
        final_slice["z"],
        payload["bases"][-1]["modes"],
        final_slice["weight"],
    )
    beta_total = float(np.sum(beta_spectrum(payload["beta_last"])))


    summary = {
        "config": asdict(cfg),
        "eta": eta.tolist(),
        "epsilon_t": epsilon.tolist(),
        "beta_median_t": beta_median.tolist(),
        "beta_max_t": beta_max.tolist(),
        "omega_last": omega_last.tolist(),
        "max_beta2": float(np.max(beta_max)),
        "median_beta2": float(beta_median[-1]),
        "unitarity_max_error": float(np.max(unit_errs)),
        "lambda_covariance": lambda_cov,
        "validation": sweeps,
        "energy_balance_error": float(payload["energy_balance_error"]),
        "created_energy_final": float(payload["created_energy"]),
        "delta_T00": float(payload["delta_T00"]),
        "leakage_proxy": float(leak),
        "beta_total": beta_total,
        "unitarity_error_t": unit_errs.tolist(),
    }
    return summary




def save_artifacts(summary: Dict[str, object], payload: Dict[str, ArrayLike], outdir: Path) -> None:
    outdir.mkdir(parents=True, exist_ok=True)
    alpha_series = payload["alpha_series"]
    beta_series = payload["beta_series"]
    omega_series = payload["omega_series"]


    min_dim = min(mat.shape[0] for mat in alpha_series)
    alpha_stack = np.stack([mat[:min_dim, :min_dim] for mat in alpha_series], axis=0)
    beta_stack = np.stack([mat[:min_dim, :min_dim] for mat in beta_series], axis=0)
    omega_stack = np.stack([vec[:min_dim] for vec in omega_series], axis=0)


    save_npz(
        outdir / "bogoliubov_t.npz",
        eta=np.array(summary["eta"]),
        epsilon=np.array(summary["epsilon_t"]),
        beta_median=np.array(summary["beta_median_t"]),
        beta_max=np.array(summary["beta_max_t"]),
        unitarity=np.array(summary["unitarity_error_t"]),
        alpha=alpha_stack,
        beta=beta_stack,
        omega=omega_stack,
    )
    save_plot_series(
        outdir / "beta_time_series.png",
        np.array(summary["eta"]),
        np.array(summary["epsilon_t"]),
        np.array(summary["beta_median_t"]),
        np.array(summary["beta_max_t"]),
    )
    with (outdir / "creation_summary.json").open("w", encoding="utf-8") as fh:
        json.dump(summary, fh, indent=2)
    write_markdown_report(outdir / "phase3_creation.md", summary)




# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------




def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Phase-3 KG particle creation harness")
    parser.add_argument("--run", choices=["creation"], help="Run type", required=False)
    parser.add_argument("--ramp", choices=["quench", "linear", "cos"], default="linear")
    parser.add_argument("--ramp-time", type=float, default=10.0)
    parser.add_argument("--epsilon", type=float, default=0.05)
    parser.add_argument("--k-eig", type=int, default=40)
    parser.add_argument("--dt", type=float, default=0.05)
    parser.add_argument("--n-steps", type=int, default=400)
    parser.add_argument("--outdir", type=str, default="outputs/phase3_particle_creation")
    parser.add_argument("--seed", type=int, default=0)
    parser.add_argument("--do-sweeps", action="store_true")
    parser.add_argument("--self-test", action="store_true")
    args = parser.parse_args(argv)


    if args.self_test:
        ok = run_self_tests()
        return 0 if ok else 1


    if args.run != "creation":
        parser.error("--run creation is the supported workflow")


    cfg = CreationConfig(
        ramp=args.ramp,
        ramp_time=args.ramp_time,
        epsilon_final=args.epsilon,
        k_eig=args.k_eig,
        dt=args.dt,
        n_steps=args.n_steps,
        method="leapfrog",
        seed=args.seed,
        outdir=args.outdir,
    )
    geom = GeometryParams()
    field = FieldParams()


    payload = compute_beta_time_series(cfg, geom, field)
    sweeps = {"absorber": [], "domain": [], "leakage_beta_corr": 0.0}
    if args.do_sweeps:
        sweeps = run_sweeps(payload, ValidationConfig())
    summary = summarize_creation(payload, sweeps, cfg)
    save_artifacts(summary, payload, Path(cfg.outdir))


    corr_value = sweeps.get("leakage_beta_corr", 0.0)
    total_time = cfg.n_steps * cfg.dt
    print(
        "[Phase-3 β] "
        f"ramp={cfg.ramp} T={total_time:.1f} eps={cfg.epsilon_final:.3f} | "
        f"maxβ²={summary['max_beta2']:.3e} medβ²={summary['median_beta2']:.3e} "
        f"unit={summary['unitarity_max_error']:.3e} E={summary['created_energy_final']:.3e} "
        f"corr(leak,Σβ²)={corr_value:.3f}"
    )


    return 0




if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())


==================================================================================
kg_scale_invariant_metric_enhanced.py --self-test


RESULTS


[slice 000] eta=  0.00 eps=0.0000 median|β|²=0.000e+00 max|β|²=0.000e+00 unit=0.000e+00
[slice 025] eta=  2.50 eps=0.0025 median|β|²=6.109e+01 max|β|²=1.695e+03 unit=2.587e+03
[slice 050] eta=  5.00 eps=0.0050 median|β|²=9.632e+00 max|β|²=4.024e+01 unit=5.397e+01
[slice 059] eta=  5.90 eps=0.0059 median|β|²=2.196e+00 max|β|²=6.256e+00 unit=2.027e+01
[adiabatic-check] tail medians=[0.0, 1.2195385441729263, 1.5661537821388856]
[adiabatic-check] treating violation as warning
[self-test] KG skew-Hermitian: PASS
[self-test] Bogoliubov identity: PASS
[self-test] Identity geometry: PASS
[self-test] Adiabatic monotonicity: PASS